
from smsp.schema_utils import *
from smsp.schema_utils import _cast
if True:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)


class Person_Gender(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, value=None, semanticsText=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.value = value
        self.semanticsText = semanticsText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person_Gender)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person_Gender.subclass:
            return Person_Gender.subclass(*args_, **kwargs_)
        else:
            return Person_Gender(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_semanticsText(self): return self.semanticsText
    def set_semanticsText(self, semanticsText): self.semanticsText = semanticsText
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.value is not None or
            self.semanticsText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000002GB01.Person.Gender', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000002GB01.Person.Gender')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000002GB01.Person.Gender')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000002GB01.Person.Gender', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000002GB01.Person.Gender'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000002GB01.Person.Gender', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.semanticsText is not None:
            self.semanticsText.export(outfile, level, namespace_, name_='semanticsText', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'value':
            obj_ = valueType.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'semanticsText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semanticsText = obj_
            obj_.original_tagname_ = 'semanticsText'


class Person_LocalIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, value=None, semanticsText=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.value = value
        self.semanticsText = semanticsText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person_LocalIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person_LocalIdentifier.subclass:
            return Person_LocalIdentifier.subclass(*args_, **kwargs_)
        else:
            return Person_LocalIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_semanticsText(self): return self.semanticsText
    def set_semanticsText(self, semanticsText): self.semanticsText = semanticsText
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.value is not None or
            self.semanticsText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000002GB01.Person.LocalIdentifier', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000002GB01.Person.LocalIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000002GB01.Person.LocalIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000002GB01.Person.LocalIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000002GB01.Person.LocalIdentifier'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000002GB01.Person.LocalIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.semanticsText is not None:
            self.semanticsText.export(outfile, level, namespace_, name_='semanticsText', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'value':
            obj_ = II_NHS_IdentifierType3.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'semanticsText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semanticsText = obj_
            obj_.original_tagname_ = 'semanticsText'


class Person_Postcode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, value=None, semanticsText=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.value = value
        self.semanticsText = semanticsText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person_Postcode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person_Postcode.subclass:
            return Person_Postcode.subclass(*args_, **kwargs_)
        else:
            return Person_Postcode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_semanticsText(self): return self.semanticsText
    def set_semanticsText(self, semanticsText): self.semanticsText = semanticsText
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.value is not None or
            self.semanticsText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000002GB01.Person.Postcode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000002GB01.Person.Postcode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000002GB01.Person.Postcode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000002GB01.Person.Postcode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000002GB01.Person.Postcode'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000002GB01.Person.Postcode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.semanticsText is not None:
            self.semanticsText.export(outfile, level, namespace_, name_='semanticsText', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'value':
            obj_ = AD_NHS_AddressType1.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'semanticsText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semanticsText = obj_
            obj_.original_tagname_ = 'semanticsText'


class getPatientDetails_v1_0(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classCode=None, moodCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, id=None, code=None, queryEvent=None):
        self.original_tagname_ = None
        self.classCode = _cast(None, classCode)
        self.moodCode = _cast(None, moodCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.id = id
        self.code = code
        self.queryEvent = queryEvent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, getPatientDetails_v1_0)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if getPatientDetails_v1_0.subclass:
            return getPatientDetails_v1_0.subclass(*args_, **kwargs_)
        else:
            return getPatientDetails_v1_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_queryEvent(self): return self.queryEvent
    def set_queryEvent(self, queryEvent): self.queryEvent = queryEvent
    def get_classCode(self): return self.classCode
    def set_classCode(self, classCode): self.classCode = classCode
    def get_moodCode(self): return self.moodCode
    def set_moodCode(self, moodCode): self.moodCode = moodCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.code is not None or
            self.queryEvent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000005GB01.getPatientDetails-v1-0', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000005GB01.getPatientDetails-v1-0')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000005GB01.getPatientDetails-v1-0')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000005GB01.getPatientDetails-v1-0', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000005GB01.getPatientDetails-v1-0'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000005GB01.getPatientDetails-v1-0', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
        if self.code is not None:
            self.code.export(outfile, level, namespace_, name_='code', pretty_print=pretty_print)
        if self.queryEvent is not None:
            self.queryEvent.export(outfile, level, namespace_, name_='queryEvent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_cs(self.classCode)    # validate type cs
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_cs(self.moodCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II_NHS_IdentifierType2.factory()
            obj_.build(child_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'code':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'queryEvent':
            obj_ = getPatientDetailsRequest_v1_0Grouper.factory()
            obj_.build(child_)
            self.queryEvent = obj_
            obj_.original_tagname_ = 'queryEvent'


class ANY(GeneratedsSuper):
    """Defines the basic properties of every data value. This is an
    abstract type, meaning that no value can be just a data value
    without belonging to any concrete type. Every concrete type is a
    specialization of this general abstract DataValue type. An
    exceptional value expressing missing information and possibly
    the reason why the information is missing."""
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANY.subclass:
            return ANY.subclass(*args_, **kwargs_)
        else:
            return ANY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ANY', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANY')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANY'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ANY', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class AD(ANY):
    """Mailing and home or office addresses. A sequence of address parts,
    such as street or post office Box, city, postal code, country,
    etc. A set of codes advising a system or user which address in a
    set of like addresses to select for a given purpose. A boolean
    value specifying whether the order of the address parts is known
    or not. While the address parts are always a Sequence, the order
    in which they are presented may or may not be known. Where this
    matters, the isNotOrdered property can be used to convey this
    information."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, use=None, isNotOrdered=None, delimiter=None, country=None, state=None, county=None, city=None, postalCode=None, streetAddressLine=None, houseNumber=None, houseNumberNumeric=None, direction=None, streetName=None, streetNameBase=None, streetNameType=None, additionalLocator=None, unitID=None, unitType=None, carrier=None, censusTract=None, addressKey=None, desc=None, useablePeriod=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(AD, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        self.isNotOrdered = _cast(None, isNotOrdered)
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        if country is None:
            self.country = []
        else:
            self.country = country
        if state is None:
            self.state = []
        else:
            self.state = state
        if county is None:
            self.county = []
        else:
            self.county = county
        if city is None:
            self.city = []
        else:
            self.city = city
        if postalCode is None:
            self.postalCode = []
        else:
            self.postalCode = postalCode
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
        if houseNumber is None:
            self.houseNumber = []
        else:
            self.houseNumber = houseNumber
        if houseNumberNumeric is None:
            self.houseNumberNumeric = []
        else:
            self.houseNumberNumeric = houseNumberNumeric
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        if streetName is None:
            self.streetName = []
        else:
            self.streetName = streetName
        if streetNameBase is None:
            self.streetNameBase = []
        else:
            self.streetNameBase = streetNameBase
        if streetNameType is None:
            self.streetNameType = []
        else:
            self.streetNameType = streetNameType
        if additionalLocator is None:
            self.additionalLocator = []
        else:
            self.additionalLocator = additionalLocator
        if unitID is None:
            self.unitID = []
        else:
            self.unitID = unitID
        if unitType is None:
            self.unitType = []
        else:
            self.unitType = unitType
        if carrier is None:
            self.carrier = []
        else:
            self.carrier = carrier
        if censusTract is None:
            self.censusTract = []
        else:
            self.censusTract = censusTract
        if addressKey is None:
            self.addressKey = []
        else:
            self.addressKey = addressKey
        if desc is None:
            self.desc = []
        else:
            self.desc = desc
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.id = id
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD.subclass:
            return AD.subclass(*args_, **kwargs_)
        else:
            return AD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def add_delimiter(self, value): self.delimiter.append(value)
    def insert_delimiter_at(self, index, value): self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value): self.delimiter[index] = value
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def add_country(self, value): self.country.append(value)
    def insert_country_at(self, index, value): self.country.insert(index, value)
    def replace_country_at(self, index, value): self.country[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state_at(self, index, value): self.state.insert(index, value)
    def replace_state_at(self, index, value): self.state[index] = value
    def get_county(self): return self.county
    def set_county(self, county): self.county = county
    def add_county(self, value): self.county.append(value)
    def insert_county_at(self, index, value): self.county.insert(index, value)
    def replace_county_at(self, index, value): self.county[index] = value
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def add_city(self, value): self.city.append(value)
    def insert_city_at(self, index, value): self.city.insert(index, value)
    def replace_city_at(self, index, value): self.city[index] = value
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def add_postalCode(self, value): self.postalCode.append(value)
    def insert_postalCode_at(self, index, value): self.postalCode.insert(index, value)
    def replace_postalCode_at(self, index, value): self.postalCode[index] = value
    def get_streetAddressLine(self): return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine): self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value): self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value): self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value): self.streetAddressLine[index] = value
    def get_houseNumber(self): return self.houseNumber
    def set_houseNumber(self, houseNumber): self.houseNumber = houseNumber
    def add_houseNumber(self, value): self.houseNumber.append(value)
    def insert_houseNumber_at(self, index, value): self.houseNumber.insert(index, value)
    def replace_houseNumber_at(self, index, value): self.houseNumber[index] = value
    def get_houseNumberNumeric(self): return self.houseNumberNumeric
    def set_houseNumberNumeric(self, houseNumberNumeric): self.houseNumberNumeric = houseNumberNumeric
    def add_houseNumberNumeric(self, value): self.houseNumberNumeric.append(value)
    def insert_houseNumberNumeric_at(self, index, value): self.houseNumberNumeric.insert(index, value)
    def replace_houseNumberNumeric_at(self, index, value): self.houseNumberNumeric[index] = value
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def add_direction(self, value): self.direction.append(value)
    def insert_direction_at(self, index, value): self.direction.insert(index, value)
    def replace_direction_at(self, index, value): self.direction[index] = value
    def get_streetName(self): return self.streetName
    def set_streetName(self, streetName): self.streetName = streetName
    def add_streetName(self, value): self.streetName.append(value)
    def insert_streetName_at(self, index, value): self.streetName.insert(index, value)
    def replace_streetName_at(self, index, value): self.streetName[index] = value
    def get_streetNameBase(self): return self.streetNameBase
    def set_streetNameBase(self, streetNameBase): self.streetNameBase = streetNameBase
    def add_streetNameBase(self, value): self.streetNameBase.append(value)
    def insert_streetNameBase_at(self, index, value): self.streetNameBase.insert(index, value)
    def replace_streetNameBase_at(self, index, value): self.streetNameBase[index] = value
    def get_streetNameType(self): return self.streetNameType
    def set_streetNameType(self, streetNameType): self.streetNameType = streetNameType
    def add_streetNameType(self, value): self.streetNameType.append(value)
    def insert_streetNameType_at(self, index, value): self.streetNameType.insert(index, value)
    def replace_streetNameType_at(self, index, value): self.streetNameType[index] = value
    def get_additionalLocator(self): return self.additionalLocator
    def set_additionalLocator(self, additionalLocator): self.additionalLocator = additionalLocator
    def add_additionalLocator(self, value): self.additionalLocator.append(value)
    def insert_additionalLocator_at(self, index, value): self.additionalLocator.insert(index, value)
    def replace_additionalLocator_at(self, index, value): self.additionalLocator[index] = value
    def get_unitID(self): return self.unitID
    def set_unitID(self, unitID): self.unitID = unitID
    def add_unitID(self, value): self.unitID.append(value)
    def insert_unitID_at(self, index, value): self.unitID.insert(index, value)
    def replace_unitID_at(self, index, value): self.unitID[index] = value
    def get_unitType(self): return self.unitType
    def set_unitType(self, unitType): self.unitType = unitType
    def add_unitType(self, value): self.unitType.append(value)
    def insert_unitType_at(self, index, value): self.unitType.insert(index, value)
    def replace_unitType_at(self, index, value): self.unitType[index] = value
    def get_carrier(self): return self.carrier
    def set_carrier(self, carrier): self.carrier = carrier
    def add_carrier(self, value): self.carrier.append(value)
    def insert_carrier_at(self, index, value): self.carrier.insert(index, value)
    def replace_carrier_at(self, index, value): self.carrier[index] = value
    def get_censusTract(self): return self.censusTract
    def set_censusTract(self, censusTract): self.censusTract = censusTract
    def add_censusTract(self, value): self.censusTract.append(value)
    def insert_censusTract_at(self, index, value): self.censusTract.insert(index, value)
    def replace_censusTract_at(self, index, value): self.censusTract[index] = value
    def get_addressKey(self): return self.addressKey
    def set_addressKey(self, addressKey): self.addressKey = addressKey
    def add_addressKey(self, value): self.addressKey.append(value)
    def insert_addressKey_at(self, index, value): self.addressKey.insert(index, value)
    def replace_addressKey_at(self, index, value): self.addressKey[index] = value
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def add_desc(self, value): self.desc.append(value)
    def insert_desc_at(self, index, value): self.desc.insert(index, value)
    def replace_desc_at(self, index, value): self.desc[index] = value
    def get_useablePeriod(self): return self.useablePeriod
    def set_useablePeriod(self, useablePeriod): self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value): self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value): self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value): self.useablePeriod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_isNotOrdered(self): return self.isNotOrdered
    def set_isNotOrdered(self, isNotOrdered): self.isNotOrdered = isNotOrdered
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_PostalAddressUse(self, value):
        # Validate type set_cs_PostalAddressUse, a restriction on cs_PostalAddressUse.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            self.delimiter or
            self.country or
            self.state or
            self.county or
            self.city or
            self.postalCode or
            self.streetAddressLine or
            self.houseNumber or
            self.houseNumberNumeric or
            self.direction or
            self.streetName or
            self.streetNameBase or
            self.streetNameType or
            self.additionalLocator or
            self.unitID or
            self.unitType or
            self.carrier or
            self.censusTract or
            self.addressKey or
            self.desc or
            self.useablePeriod or
            self.id is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AD', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AD'):
        super(AD, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AD')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.isNotOrdered is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            outfile.write(' isNotOrdered=%s' % (quote_attrib(self.isNotOrdered), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AD', fromsubclass_=False, pretty_print=True):
        super(AD, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            delimiter_.export(outfile, level, namespace_, name_='delimiter', pretty_print=pretty_print)
        for country_ in self.country:
            country_.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state', pretty_print=pretty_print)
        for county_ in self.county:
            county_.export(outfile, level, namespace_, name_='county', pretty_print=pretty_print)
        for city_ in self.city:
            city_.export(outfile, level, namespace_, name_='city', pretty_print=pretty_print)
        for postalCode_ in self.postalCode:
            postalCode_.export(outfile, level, namespace_, name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            streetAddressLine_.export(outfile, level, namespace_, name_='streetAddressLine', pretty_print=pretty_print)
        for houseNumber_ in self.houseNumber:
            houseNumber_.export(outfile, level, namespace_, name_='houseNumber', pretty_print=pretty_print)
        for houseNumberNumeric_ in self.houseNumberNumeric:
            houseNumberNumeric_.export(outfile, level, namespace_, name_='houseNumberNumeric', pretty_print=pretty_print)
        for direction_ in self.direction:
            direction_.export(outfile, level, namespace_, name_='direction', pretty_print=pretty_print)
        for streetName_ in self.streetName:
            streetName_.export(outfile, level, namespace_, name_='streetName', pretty_print=pretty_print)
        for streetNameBase_ in self.streetNameBase:
            streetNameBase_.export(outfile, level, namespace_, name_='streetNameBase', pretty_print=pretty_print)
        for streetNameType_ in self.streetNameType:
            streetNameType_.export(outfile, level, namespace_, name_='streetNameType', pretty_print=pretty_print)
        for additionalLocator_ in self.additionalLocator:
            additionalLocator_.export(outfile, level, namespace_, name_='additionalLocator', pretty_print=pretty_print)
        for unitID_ in self.unitID:
            unitID_.export(outfile, level, namespace_, name_='unitID', pretty_print=pretty_print)
        for unitType_ in self.unitType:
            unitType_.export(outfile, level, namespace_, name_='unitType', pretty_print=pretty_print)
        for carrier_ in self.carrier:
            carrier_.export(outfile, level, namespace_, name_='carrier', pretty_print=pretty_print)
        for censusTract_ in self.censusTract:
            censusTract_.export(outfile, level, namespace_, name_='censusTract', pretty_print=pretty_print)
        for addressKey_ in self.addressKey:
            addressKey_.export(outfile, level, namespace_, name_='addressKey', pretty_print=pretty_print)
        for desc_ in self.desc:
            desc_.export(outfile, level, namespace_, name_='desc', pretty_print=pretty_print)
        for useablePeriod_ in self.useablePeriod:
            useablePeriod_.export(outfile, level, namespace_, name_='useablePeriod', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_PostalAddressUse(self.use)    # validate type set_cs_PostalAddressUse
        value = find_attr_value_('isNotOrdered', node)
        if value is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            self.isNotOrdered = value
            self.validate_bl(self.isNotOrdered)    # validate type bl
        super(AD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'delimiter':
            obj_ = delimiterType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'country':
            obj_ = countryType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'country', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_country'):
              self.add_country(obj_.value)
            elif hasattr(self, 'set_country'):
              self.set_country(obj_.value)
        elif nodeName_ == 'state':
            obj_ = stateType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'state', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_state'):
              self.add_state(obj_.value)
            elif hasattr(self, 'set_state'):
              self.set_state(obj_.value)
        elif nodeName_ == 'county':
            obj_ = countyType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'county', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_county'):
              self.add_county(obj_.value)
            elif hasattr(self, 'set_county'):
              self.set_county(obj_.value)
        elif nodeName_ == 'city':
            obj_ = cityType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'city', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_city'):
              self.add_city(obj_.value)
            elif hasattr(self, 'set_city'):
              self.set_city(obj_.value)
        elif nodeName_ == 'postalCode':
            obj_ = postalCodeType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = streetAddressLineType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        elif nodeName_ == 'houseNumber':
            obj_ = houseNumberType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumber', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumber'):
              self.add_houseNumber(obj_.value)
            elif hasattr(self, 'set_houseNumber'):
              self.set_houseNumber(obj_.value)
        elif nodeName_ == 'houseNumberNumeric':
            obj_ = houseNumberNumericType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumberNumeric', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumberNumeric'):
              self.add_houseNumberNumeric(obj_.value)
            elif hasattr(self, 'set_houseNumberNumeric'):
              self.set_houseNumberNumeric(obj_.value)
        elif nodeName_ == 'direction':
            obj_ = directionType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'direction', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_direction'):
              self.add_direction(obj_.value)
            elif hasattr(self, 'set_direction'):
              self.set_direction(obj_.value)
        elif nodeName_ == 'streetName':
            obj_ = streetNameType1.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetName', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetName'):
              self.add_streetName(obj_.value)
            elif hasattr(self, 'set_streetName'):
              self.set_streetName(obj_.value)
        elif nodeName_ == 'streetNameBase':
            obj_ = streetNameBaseType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameBase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameBase'):
              self.add_streetNameBase(obj_.value)
            elif hasattr(self, 'set_streetNameBase'):
              self.set_streetNameBase(obj_.value)
        elif nodeName_ == 'streetNameType':
            obj_ = streetNameTypeType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameType'):
              self.add_streetNameType(obj_.value)
            elif hasattr(self, 'set_streetNameType'):
              self.set_streetNameType(obj_.value)
        elif nodeName_ == 'additionalLocator':
            obj_ = additionalLocatorType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'additionalLocator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_additionalLocator'):
              self.add_additionalLocator(obj_.value)
            elif hasattr(self, 'set_additionalLocator'):
              self.set_additionalLocator(obj_.value)
        elif nodeName_ == 'unitID':
            obj_ = unitIDType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitID', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitID'):
              self.add_unitID(obj_.value)
            elif hasattr(self, 'set_unitID'):
              self.set_unitID(obj_.value)
        elif nodeName_ == 'unitType':
            obj_ = unitTypeType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitType'):
              self.add_unitType(obj_.value)
            elif hasattr(self, 'set_unitType'):
              self.set_unitType(obj_.value)
        elif nodeName_ == 'carrier':
            obj_ = carrierType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'carrier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_carrier'):
              self.add_carrier(obj_.value)
            elif hasattr(self, 'set_carrier'):
              self.set_carrier(obj_.value)
        elif nodeName_ == 'censusTract':
            obj_ = censusTractType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'censusTract', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_censusTract'):
              self.add_censusTract(obj_.value)
            elif hasattr(self, 'set_censusTract'):
              self.set_censusTract(obj_.value)
        elif nodeName_ == 'addressKey':
            obj_ = addressKeyType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'addressKey', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_addressKey'):
              self.add_addressKey(obj_.value)
            elif hasattr(self, 'set_addressKey'):
              self.set_addressKey(obj_.value)
        elif nodeName_ == 'desc':
            obj_ = descType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'desc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_desc'):
              self.add_desc(obj_.value)
            elif hasattr(self, 'set_desc'):
              self.set_desc(obj_.value)
        elif nodeName_ == 'useablePeriod':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'id', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_id'):
              self.add_id(obj_.value)
            elif hasattr(self, 'set_id'):
              self.set_id(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AD, self).buildChildren(child_, node, nodeName_, True)


class AD_NHS_Internal(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, use=None, postalCode=None, streetAddressLine=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(AD_NHS_Internal, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        self.postalCode = postalCode
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD_NHS_Internal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD_NHS_Internal.subclass:
            return AD_NHS_Internal.subclass(*args_, **kwargs_)
        else:
            return AD_NHS_Internal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_streetAddressLine(self): return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine): self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value): self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value): self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value): self.streetAddressLine[index] = value
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_PostalAddressUse(self, value):
        # Validate type set_cs_PostalAddressUse, a restriction on cs_PostalAddressUse.
        pass
    def hasContent_(self):
        if (
            self.postalCode is not None or
            self.streetAddressLine or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AD_NHS_Internal, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AD.NHS.Internal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD.NHS.Internal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NHS.Internal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AD.NHS.Internal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AD.NHS.Internal'):
        super(AD_NHS_Internal, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NHS.Internal')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AD.NHS.Internal', fromsubclass_=False, pretty_print=True):
        super(AD_NHS_Internal, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.postalCode is not None:
            self.postalCode.export(outfile, level, namespace_, name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            streetAddressLine_.export(outfile, level, namespace_, name_='streetAddressLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_PostalAddressUse(self.use)    # validate type set_cs_PostalAddressUse
        super(AD_NHS_Internal, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'postalCode':
            obj_ = ADXP.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = ADXP.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AD_NHS_Internal, self).buildChildren(child_, node, nodeName_, True)


class AD_NHS_AddressType1(AD_NHS_Internal):
    subclass = None
    superclass = AD_NHS_Internal
    def __init__(self, nullFlavor=None, updateMode=None, use=None, postalCode=None, streetAddressLine=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(AD_NHS_AddressType1, self).__init__(nullFlavor, updateMode, use, postalCode, streetAddressLine, valueOf_, mixedclass_, content_, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.use = _cast(None, use)
        self.postalCode = postalCode
        self.streetAddressLine = streetAddressLine
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD_NHS_AddressType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD_NHS_AddressType1.subclass:
            return AD_NHS_AddressType1.subclass(*args_, **kwargs_)
        else:
            return AD_NHS_AddressType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_streetAddressLine(self): return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine): self.streetAddressLine = streetAddressLine
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_set_cs_PostalAddressUse(self, value):
        # Validate type set_cs_PostalAddressUse, a restriction on cs_PostalAddressUse.
        pass
    def hasContent_(self):
        if (
            self.postalCode is not None or
            self.streetAddressLine is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AD_NHS_AddressType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AD.NHS.AddressType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD.NHS.AddressType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NHS.AddressType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AD.NHS.AddressType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AD.NHS.AddressType1'):
        super(AD_NHS_AddressType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NHS.AddressType1')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AD.NHS.AddressType1', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.postalCode is not None:
            self.postalCode.export(outfile, level, namespace_, name_='postalCode', pretty_print=pretty_print)
        if self.streetAddressLine is not None:
            self.streetAddressLine.export(outfile, level, namespace_, name_='streetAddressLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_PostalAddressUse(self.use)    # validate type set_cs_PostalAddressUse
        super(AD_NHS_AddressType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'postalCode':
            obj_ = ADXP.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = ADXP.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class AD_NHS_AddressType2(AD_NHS_Internal):
    subclass = None
    superclass = AD_NHS_Internal
    def __init__(self, nullFlavor=None, updateMode=None, use=None, postalCode=None, streetAddressLine=None):
        self.original_tagname_ = None
        super(AD_NHS_AddressType2, self).__init__(nullFlavor, updateMode, use, postalCode, streetAddressLine, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.use = _cast(None, use)
        self.postalCode = postalCode
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD_NHS_AddressType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD_NHS_AddressType2.subclass:
            return AD_NHS_AddressType2.subclass(*args_, **kwargs_)
        else:
            return AD_NHS_AddressType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_streetAddressLine(self): return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine): self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value): self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value): self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value): self.streetAddressLine[index] = value
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_set_cs_PostalAddressUse(self, value):
        # Validate type set_cs_PostalAddressUse, a restriction on cs_PostalAddressUse.
        pass
    def hasContent_(self):
        if (
            self.postalCode is not None or
            self.streetAddressLine or
            super(AD_NHS_AddressType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AD.NHS.AddressType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD.NHS.AddressType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NHS.AddressType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AD.NHS.AddressType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AD.NHS.AddressType2'):
        super(AD_NHS_AddressType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NHS.AddressType2')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AD.NHS.AddressType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.postalCode is not None:
            self.postalCode.export(outfile, level, namespace_, name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            streetAddressLine_.export(outfile, level, namespace_, name_='streetAddressLine', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_PostalAddressUse(self.use)    # validate type set_cs_PostalAddressUse
        super(AD_NHS_AddressType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'postalCode':
            obj_ = ADXP.factory()
            obj_.build(child_)
            self.postalCode = obj_
            obj_.original_tagname_ = 'postalCode'
        elif nodeName_ == 'streetAddressLine':
            obj_ = ADXP.factory()
            obj_.build(child_)
            self.streetAddressLine.append(obj_)
            obj_.original_tagname_ = 'streetAddressLine'


class AD_NPfIT_CodedCountry(ANY):
    """Mailing and home or office addresses. A sequence of address parts,
    such as street or post office Box, city, postal code, country,
    etc. A set of codes advising a system or user which address in a
    set of like addresses to select for a given purpose. A boolean
    value specifying whether the order of the address parts is known
    or not. While the address parts are always a Sequence, the order
    in which they are presented may or may not be known. Where this
    matters, the isNotOrdered property can be used to convey this
    information."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, use=None, isNotOrdered=None, delimiter=None, country=None, state=None, county=None, city=None, postalCode=None, streetAddressLine=None, houseNumber=None, houseNumberNumeric=None, direction=None, streetName=None, streetNameBase=None, streetNameType=None, additionalLocator=None, unitID=None, unitType=None, carrier=None, censusTract=None, addressKey=None, desc=None, useablePeriod=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(AD_NPfIT_CodedCountry, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        self.isNotOrdered = _cast(None, isNotOrdered)
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        if country is None:
            self.country = []
        else:
            self.country = country
        if state is None:
            self.state = []
        else:
            self.state = state
        if county is None:
            self.county = []
        else:
            self.county = county
        if city is None:
            self.city = []
        else:
            self.city = city
        if postalCode is None:
            self.postalCode = []
        else:
            self.postalCode = postalCode
        if streetAddressLine is None:
            self.streetAddressLine = []
        else:
            self.streetAddressLine = streetAddressLine
        if houseNumber is None:
            self.houseNumber = []
        else:
            self.houseNumber = houseNumber
        if houseNumberNumeric is None:
            self.houseNumberNumeric = []
        else:
            self.houseNumberNumeric = houseNumberNumeric
        if direction is None:
            self.direction = []
        else:
            self.direction = direction
        if streetName is None:
            self.streetName = []
        else:
            self.streetName = streetName
        if streetNameBase is None:
            self.streetNameBase = []
        else:
            self.streetNameBase = streetNameBase
        if streetNameType is None:
            self.streetNameType = []
        else:
            self.streetNameType = streetNameType
        if additionalLocator is None:
            self.additionalLocator = []
        else:
            self.additionalLocator = additionalLocator
        if unitID is None:
            self.unitID = []
        else:
            self.unitID = unitID
        if unitType is None:
            self.unitType = []
        else:
            self.unitType = unitType
        if carrier is None:
            self.carrier = []
        else:
            self.carrier = carrier
        if censusTract is None:
            self.censusTract = []
        else:
            self.censusTract = censusTract
        if addressKey is None:
            self.addressKey = []
        else:
            self.addressKey = addressKey
        if desc is None:
            self.desc = []
        else:
            self.desc = desc
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.id = id
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AD_NPfIT_CodedCountry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AD_NPfIT_CodedCountry.subclass:
            return AD_NPfIT_CodedCountry.subclass(*args_, **kwargs_)
        else:
            return AD_NPfIT_CodedCountry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def add_delimiter(self, value): self.delimiter.append(value)
    def insert_delimiter_at(self, index, value): self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value): self.delimiter[index] = value
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def add_country(self, value): self.country.append(value)
    def insert_country_at(self, index, value): self.country.insert(index, value)
    def replace_country_at(self, index, value): self.country[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state_at(self, index, value): self.state.insert(index, value)
    def replace_state_at(self, index, value): self.state[index] = value
    def get_county(self): return self.county
    def set_county(self, county): self.county = county
    def add_county(self, value): self.county.append(value)
    def insert_county_at(self, index, value): self.county.insert(index, value)
    def replace_county_at(self, index, value): self.county[index] = value
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def add_city(self, value): self.city.append(value)
    def insert_city_at(self, index, value): self.city.insert(index, value)
    def replace_city_at(self, index, value): self.city[index] = value
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def add_postalCode(self, value): self.postalCode.append(value)
    def insert_postalCode_at(self, index, value): self.postalCode.insert(index, value)
    def replace_postalCode_at(self, index, value): self.postalCode[index] = value
    def get_streetAddressLine(self): return self.streetAddressLine
    def set_streetAddressLine(self, streetAddressLine): self.streetAddressLine = streetAddressLine
    def add_streetAddressLine(self, value): self.streetAddressLine.append(value)
    def insert_streetAddressLine_at(self, index, value): self.streetAddressLine.insert(index, value)
    def replace_streetAddressLine_at(self, index, value): self.streetAddressLine[index] = value
    def get_houseNumber(self): return self.houseNumber
    def set_houseNumber(self, houseNumber): self.houseNumber = houseNumber
    def add_houseNumber(self, value): self.houseNumber.append(value)
    def insert_houseNumber_at(self, index, value): self.houseNumber.insert(index, value)
    def replace_houseNumber_at(self, index, value): self.houseNumber[index] = value
    def get_houseNumberNumeric(self): return self.houseNumberNumeric
    def set_houseNumberNumeric(self, houseNumberNumeric): self.houseNumberNumeric = houseNumberNumeric
    def add_houseNumberNumeric(self, value): self.houseNumberNumeric.append(value)
    def insert_houseNumberNumeric_at(self, index, value): self.houseNumberNumeric.insert(index, value)
    def replace_houseNumberNumeric_at(self, index, value): self.houseNumberNumeric[index] = value
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def add_direction(self, value): self.direction.append(value)
    def insert_direction_at(self, index, value): self.direction.insert(index, value)
    def replace_direction_at(self, index, value): self.direction[index] = value
    def get_streetName(self): return self.streetName
    def set_streetName(self, streetName): self.streetName = streetName
    def add_streetName(self, value): self.streetName.append(value)
    def insert_streetName_at(self, index, value): self.streetName.insert(index, value)
    def replace_streetName_at(self, index, value): self.streetName[index] = value
    def get_streetNameBase(self): return self.streetNameBase
    def set_streetNameBase(self, streetNameBase): self.streetNameBase = streetNameBase
    def add_streetNameBase(self, value): self.streetNameBase.append(value)
    def insert_streetNameBase_at(self, index, value): self.streetNameBase.insert(index, value)
    def replace_streetNameBase_at(self, index, value): self.streetNameBase[index] = value
    def get_streetNameType(self): return self.streetNameType
    def set_streetNameType(self, streetNameType): self.streetNameType = streetNameType
    def add_streetNameType(self, value): self.streetNameType.append(value)
    def insert_streetNameType_at(self, index, value): self.streetNameType.insert(index, value)
    def replace_streetNameType_at(self, index, value): self.streetNameType[index] = value
    def get_additionalLocator(self): return self.additionalLocator
    def set_additionalLocator(self, additionalLocator): self.additionalLocator = additionalLocator
    def add_additionalLocator(self, value): self.additionalLocator.append(value)
    def insert_additionalLocator_at(self, index, value): self.additionalLocator.insert(index, value)
    def replace_additionalLocator_at(self, index, value): self.additionalLocator[index] = value
    def get_unitID(self): return self.unitID
    def set_unitID(self, unitID): self.unitID = unitID
    def add_unitID(self, value): self.unitID.append(value)
    def insert_unitID_at(self, index, value): self.unitID.insert(index, value)
    def replace_unitID_at(self, index, value): self.unitID[index] = value
    def get_unitType(self): return self.unitType
    def set_unitType(self, unitType): self.unitType = unitType
    def add_unitType(self, value): self.unitType.append(value)
    def insert_unitType_at(self, index, value): self.unitType.insert(index, value)
    def replace_unitType_at(self, index, value): self.unitType[index] = value
    def get_carrier(self): return self.carrier
    def set_carrier(self, carrier): self.carrier = carrier
    def add_carrier(self, value): self.carrier.append(value)
    def insert_carrier_at(self, index, value): self.carrier.insert(index, value)
    def replace_carrier_at(self, index, value): self.carrier[index] = value
    def get_censusTract(self): return self.censusTract
    def set_censusTract(self, censusTract): self.censusTract = censusTract
    def add_censusTract(self, value): self.censusTract.append(value)
    def insert_censusTract_at(self, index, value): self.censusTract.insert(index, value)
    def replace_censusTract_at(self, index, value): self.censusTract[index] = value
    def get_addressKey(self): return self.addressKey
    def set_addressKey(self, addressKey): self.addressKey = addressKey
    def add_addressKey(self, value): self.addressKey.append(value)
    def insert_addressKey_at(self, index, value): self.addressKey.insert(index, value)
    def replace_addressKey_at(self, index, value): self.addressKey[index] = value
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def add_desc(self, value): self.desc.append(value)
    def insert_desc_at(self, index, value): self.desc.insert(index, value)
    def replace_desc_at(self, index, value): self.desc[index] = value
    def get_useablePeriod(self): return self.useablePeriod
    def set_useablePeriod(self, useablePeriod): self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value): self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value): self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value): self.useablePeriod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_isNotOrdered(self): return self.isNotOrdered
    def set_isNotOrdered(self, isNotOrdered): self.isNotOrdered = isNotOrdered
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_PostalAddressUse(self, value):
        # Validate type set_cs_PostalAddressUse, a restriction on cs_PostalAddressUse.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            self.delimiter or
            self.country or
            self.state or
            self.county or
            self.city or
            self.postalCode or
            self.streetAddressLine or
            self.houseNumber or
            self.houseNumberNumeric or
            self.direction or
            self.streetName or
            self.streetNameBase or
            self.streetNameType or
            self.additionalLocator or
            self.unitID or
            self.unitType or
            self.carrier or
            self.censusTract or
            self.addressKey or
            self.desc or
            self.useablePeriod or
            self.id is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AD_NPfIT_CodedCountry, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AD.NPfIT.CodedCountry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AD.NPfIT.CodedCountry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NPfIT.CodedCountry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AD.NPfIT.CodedCountry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AD.NPfIT.CodedCountry'):
        super(AD_NPfIT_CodedCountry, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AD.NPfIT.CodedCountry')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.isNotOrdered is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            outfile.write(' isNotOrdered=%s' % (quote_attrib(self.isNotOrdered), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AD.NPfIT.CodedCountry', fromsubclass_=False, pretty_print=True):
        super(AD_NPfIT_CodedCountry, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            delimiter_.export(outfile, level, namespace_, name_='delimiter', pretty_print=pretty_print)
        for country_ in self.country:
            country_.export(outfile, level, namespace_, name_='country', pretty_print=pretty_print)
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state', pretty_print=pretty_print)
        for county_ in self.county:
            county_.export(outfile, level, namespace_, name_='county', pretty_print=pretty_print)
        for city_ in self.city:
            city_.export(outfile, level, namespace_, name_='city', pretty_print=pretty_print)
        for postalCode_ in self.postalCode:
            postalCode_.export(outfile, level, namespace_, name_='postalCode', pretty_print=pretty_print)
        for streetAddressLine_ in self.streetAddressLine:
            streetAddressLine_.export(outfile, level, namespace_, name_='streetAddressLine', pretty_print=pretty_print)
        for houseNumber_ in self.houseNumber:
            houseNumber_.export(outfile, level, namespace_, name_='houseNumber', pretty_print=pretty_print)
        for houseNumberNumeric_ in self.houseNumberNumeric:
            houseNumberNumeric_.export(outfile, level, namespace_, name_='houseNumberNumeric', pretty_print=pretty_print)
        for direction_ in self.direction:
            direction_.export(outfile, level, namespace_, name_='direction', pretty_print=pretty_print)
        for streetName_ in self.streetName:
            streetName_.export(outfile, level, namespace_, name_='streetName', pretty_print=pretty_print)
        for streetNameBase_ in self.streetNameBase:
            streetNameBase_.export(outfile, level, namespace_, name_='streetNameBase', pretty_print=pretty_print)
        for streetNameType_ in self.streetNameType:
            streetNameType_.export(outfile, level, namespace_, name_='streetNameType', pretty_print=pretty_print)
        for additionalLocator_ in self.additionalLocator:
            additionalLocator_.export(outfile, level, namespace_, name_='additionalLocator', pretty_print=pretty_print)
        for unitID_ in self.unitID:
            unitID_.export(outfile, level, namespace_, name_='unitID', pretty_print=pretty_print)
        for unitType_ in self.unitType:
            unitType_.export(outfile, level, namespace_, name_='unitType', pretty_print=pretty_print)
        for carrier_ in self.carrier:
            carrier_.export(outfile, level, namespace_, name_='carrier', pretty_print=pretty_print)
        for censusTract_ in self.censusTract:
            censusTract_.export(outfile, level, namespace_, name_='censusTract', pretty_print=pretty_print)
        for addressKey_ in self.addressKey:
            addressKey_.export(outfile, level, namespace_, name_='addressKey', pretty_print=pretty_print)
        for desc_ in self.desc:
            desc_.export(outfile, level, namespace_, name_='desc', pretty_print=pretty_print)
        for useablePeriod_ in self.useablePeriod:
            useablePeriod_.export(outfile, level, namespace_, name_='useablePeriod', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_PostalAddressUse(self.use)    # validate type set_cs_PostalAddressUse
        value = find_attr_value_('isNotOrdered', node)
        if value is not None and 'isNotOrdered' not in already_processed:
            already_processed.add('isNotOrdered')
            self.isNotOrdered = value
            self.validate_bl(self.isNotOrdered)    # validate type bl
        super(AD_NPfIT_CodedCountry, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'delimiter':
            obj_ = delimiterType3.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'country':
            obj_ = ADXP_NPfIT_Coded.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'country', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_country'):
              self.add_country(obj_.value)
            elif hasattr(self, 'set_country'):
              self.set_country(obj_.value)
        elif nodeName_ == 'state':
            obj_ = stateType4.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'state', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_state'):
              self.add_state(obj_.value)
            elif hasattr(self, 'set_state'):
              self.set_state(obj_.value)
        elif nodeName_ == 'county':
            obj_ = countyType5.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'county', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_county'):
              self.add_county(obj_.value)
            elif hasattr(self, 'set_county'):
              self.set_county(obj_.value)
        elif nodeName_ == 'city':
            obj_ = cityType6.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'city', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_city'):
              self.add_city(obj_.value)
            elif hasattr(self, 'set_city'):
              self.set_city(obj_.value)
        elif nodeName_ == 'postalCode':
            obj_ = postalCodeType7.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'postalCode', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_postalCode'):
              self.add_postalCode(obj_.value)
            elif hasattr(self, 'set_postalCode'):
              self.set_postalCode(obj_.value)
        elif nodeName_ == 'streetAddressLine':
            obj_ = streetAddressLineType8.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetAddressLine', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetAddressLine'):
              self.add_streetAddressLine(obj_.value)
            elif hasattr(self, 'set_streetAddressLine'):
              self.set_streetAddressLine(obj_.value)
        elif nodeName_ == 'houseNumber':
            obj_ = houseNumberType9.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumber', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumber'):
              self.add_houseNumber(obj_.value)
            elif hasattr(self, 'set_houseNumber'):
              self.set_houseNumber(obj_.value)
        elif nodeName_ == 'houseNumberNumeric':
            obj_ = houseNumberNumericType10.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'houseNumberNumeric', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_houseNumberNumeric'):
              self.add_houseNumberNumeric(obj_.value)
            elif hasattr(self, 'set_houseNumberNumeric'):
              self.set_houseNumberNumeric(obj_.value)
        elif nodeName_ == 'direction':
            obj_ = directionType11.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'direction', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_direction'):
              self.add_direction(obj_.value)
            elif hasattr(self, 'set_direction'):
              self.set_direction(obj_.value)
        elif nodeName_ == 'streetName':
            obj_ = streetNameType12.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetName', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetName'):
              self.add_streetName(obj_.value)
            elif hasattr(self, 'set_streetName'):
              self.set_streetName(obj_.value)
        elif nodeName_ == 'streetNameBase':
            obj_ = streetNameBaseType13.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameBase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameBase'):
              self.add_streetNameBase(obj_.value)
            elif hasattr(self, 'set_streetNameBase'):
              self.set_streetNameBase(obj_.value)
        elif nodeName_ == 'streetNameType':
            obj_ = streetNameTypeType14.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'streetNameType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_streetNameType'):
              self.add_streetNameType(obj_.value)
            elif hasattr(self, 'set_streetNameType'):
              self.set_streetNameType(obj_.value)
        elif nodeName_ == 'additionalLocator':
            obj_ = additionalLocatorType15.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'additionalLocator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_additionalLocator'):
              self.add_additionalLocator(obj_.value)
            elif hasattr(self, 'set_additionalLocator'):
              self.set_additionalLocator(obj_.value)
        elif nodeName_ == 'unitID':
            obj_ = unitIDType16.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitID', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitID'):
              self.add_unitID(obj_.value)
            elif hasattr(self, 'set_unitID'):
              self.set_unitID(obj_.value)
        elif nodeName_ == 'unitType':
            obj_ = unitTypeType17.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'unitType', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_unitType'):
              self.add_unitType(obj_.value)
            elif hasattr(self, 'set_unitType'):
              self.set_unitType(obj_.value)
        elif nodeName_ == 'carrier':
            obj_ = carrierType18.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'carrier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_carrier'):
              self.add_carrier(obj_.value)
            elif hasattr(self, 'set_carrier'):
              self.set_carrier(obj_.value)
        elif nodeName_ == 'censusTract':
            obj_ = censusTractType19.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'censusTract', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_censusTract'):
              self.add_censusTract(obj_.value)
            elif hasattr(self, 'set_censusTract'):
              self.set_censusTract(obj_.value)
        elif nodeName_ == 'addressKey':
            obj_ = addressKeyType20.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'addressKey', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_addressKey'):
              self.add_addressKey(obj_.value)
            elif hasattr(self, 'set_addressKey'):
              self.set_addressKey(obj_.value)
        elif nodeName_ == 'desc':
            obj_ = descType21.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'desc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_desc'):
              self.add_desc(obj_.value)
            elif hasattr(self, 'set_desc'):
              self.set_desc(obj_.value)
        elif nodeName_ == 'useablePeriod':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'id', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_id'):
              self.add_id(obj_.value)
            elif hasattr(self, 'set_id'):
              self.set_id(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AD_NPfIT_CodedCountry, self).buildChildren(child_, node, nodeName_, True)


class BIN(ANY):
    """Binary data is a raw block of bits. Binary data is a protected type
    that should not be declared outside the data type specification.
    Specifies the representation of the binary data that is the
    content of the binary data complex XML schema data type."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(BIN, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.representation = _cast(None, representation)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BIN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BIN.subclass:
            return BIN.subclass(*args_, **kwargs_)
        else:
            return BIN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_representation(self): return self.representation
    def set_representation(self, representation): self.representation = representation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs_BinaryDataEncoding(self, value):
        # Validate type cs_BinaryDataEncoding, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['B64', 'TXT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_BinaryDataEncoding' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BIN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BIN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BIN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BIN')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BIN'):
        super(BIN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BIN')
        if self.representation != "TXT" and 'representation' not in already_processed:
            already_processed.add('representation')
            outfile.write(' representation=%s' % (quote_attrib(self.representation), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='BIN', fromsubclass_=False, pretty_print=True):
        super(BIN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representation', node)
        if value is not None and 'representation' not in already_processed:
            already_processed.add('representation')
            self.representation = value
            self.validate_cs_BinaryDataEncoding(self.representation)    # validate type cs_BinaryDataEncoding
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BIN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(BIN, self).buildChildren(child_, node, nodeName_, True)
        pass


class Cda_NPfIT_ED(BIN):
    subclass = None
    superclass = BIN
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(Cda_NPfIT_ED, self).__init__(nullFlavor, updateMode, representation, valueOf_, mixedclass_, content_, )
        self.mediaType = _cast(None, mediaType)
        self.language = _cast(None, language)
        self.compression = _cast(None, compression)
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.reference = reference
        self.thumbnail = thumbnail
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cda_NPfIT_ED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cda_NPfIT_ED.subclass:
            return Cda_NPfIT_ED.subclass(*args_, **kwargs_)
        else:
            return Cda_NPfIT_ED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_thumbnail(self): return self.thumbnail
    def set_thumbnail(self, thumbnail): self.thumbnail = thumbnail
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_mediaType(self): return self.mediaType
    def set_mediaType(self, mediaType): self.mediaType = mediaType
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def get_integrityCheck(self): return self.integrityCheck
    def set_integrityCheck(self, integrityCheck): self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self): return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm): self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_cs_CompressionAlgorithm(self, value):
        # Validate type cs_CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DF', 'GZ', 'ZL', 'Z']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_CompressionAlgorithm' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_CompressionAlgorithm_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_CompressionAlgorithm_patterns_, ))
    validate_cs_CompressionAlgorithm_patterns_ = [['^[^\\s]*$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_cs_IntegrityCheckAlgorithm(self, value):
        # Validate type cs_IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHA-1', 'SHA-256']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_IntegrityCheckAlgorithm' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_IntegrityCheckAlgorithm_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_IntegrityCheckAlgorithm_patterns_, ))
    validate_cs_IntegrityCheckAlgorithm_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Cda_NPfIT_ED, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cda.NPfIT.ED', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cda.NPfIT.ED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cda.NPfIT.ED')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cda.NPfIT.ED', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cda.NPfIT.ED'):
        super(Cda_NPfIT_ED, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cda.NPfIT.ED')
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (quote_attrib(self.mediaType), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (quote_attrib(self.language), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Cda.NPfIT.ED', fromsubclass_=False, pretty_print=True):
        super(Cda_NPfIT_ED, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            self.reference.export(outfile, level, namespace_, name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            self.thumbnail.export(outfile, level, namespace_, name_='thumbnail', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.validate_cs_CompressionAlgorithm(self.compression)    # validate type cs_CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.validate_cs_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type cs_IntegrityCheckAlgorithm
        super(Cda_NPfIT_ED, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reference':
            obj_ = Any_NPfIT_Url.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Cda_NPfIT_ED, self).buildChildren(child_, node, nodeName_, True)


class ED(BIN):
    """Data that is primarily intended for human interpretation or for
    further machine processing is outside the scope of HL7. This
    includes unformatted or formatted written language, multimedia
    data, or structured information as defined by a different
    standard (e.g., XML-signatures.) Instead of the data itself, an
    ED may contain only a reference (see TEL.) Note that the ST data
    type is a specialization of the ED data type when the ED media
    type is text/plain. Identifies the type of the encapsulated data
    and identifies a method to interpret or render the data. For
    character based information the language property specifies the
    human language of the text. Indicates whether the raw byte data
    is compressed, and what compression algorithm was used. The
    integrity check is a short binary value representing a
    cryptographically strong checksum that is calculated over the
    binary data. The purpose of this property, when communicated
    with a reference is for anyone to validate later whether the
    reference still resolved to the same data that the reference
    resolved to when the encapsulated data value with reference was
    created. Specifies the algorithm used to compute the
    integrityCheck value."""
    subclass = None
    superclass = BIN
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(ED, self).__init__(nullFlavor, updateMode, representation, valueOf_, mixedclass_, content_, )
        self.mediaType = _cast(None, mediaType)
        self.language = _cast(None, language)
        self.compression = _cast(None, compression)
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.reference = reference
        self.thumbnail = thumbnail
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ED.subclass:
            return ED.subclass(*args_, **kwargs_)
        else:
            return ED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_thumbnail(self): return self.thumbnail
    def set_thumbnail(self, thumbnail): self.thumbnail = thumbnail
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_mediaType(self): return self.mediaType
    def set_mediaType(self, mediaType): self.mediaType = mediaType
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def get_integrityCheck(self): return self.integrityCheck
    def set_integrityCheck(self, integrityCheck): self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self): return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm): self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_cs_CompressionAlgorithm(self, value):
        # Validate type cs_CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DF', 'GZ', 'ZL', 'Z']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_CompressionAlgorithm' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_CompressionAlgorithm_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_CompressionAlgorithm_patterns_, ))
    validate_cs_CompressionAlgorithm_patterns_ = [['^[^\\s]*$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_cs_IntegrityCheckAlgorithm(self, value):
        # Validate type cs_IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHA-1', 'SHA-256']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_IntegrityCheckAlgorithm' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_IntegrityCheckAlgorithm_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_IntegrityCheckAlgorithm_patterns_, ))
    validate_cs_IntegrityCheckAlgorithm_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ED, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ED', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ED')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ED', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ED'):
        super(ED, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ED')
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (quote_attrib(self.mediaType), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (quote_attrib(self.language), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ED', fromsubclass_=False, pretty_print=True):
        super(ED, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            self.reference.export(outfile, level, namespace_, name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            self.thumbnail.export(outfile, level, namespace_, name_='thumbnail', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.validate_cs_CompressionAlgorithm(self.compression)    # validate type cs_CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.validate_cs_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type cs_IntegrityCheckAlgorithm
        super(ED, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reference':
            obj_ = TEL.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ED, self).buildChildren(child_, node, nodeName_, True)


class ED_NPfIT_Text_XHTML(ED):
    """This is falvour ED data type to restrict only XHTML TEXT as content
    within the ED data. This falvour would be used in POC and GP2GP
    summart messages."""
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, html=None):
        self.original_tagname_ = None
        super(ED_NPfIT_Text_XHTML, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, )
        self.html = html
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ED_NPfIT_Text_XHTML)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ED_NPfIT_Text_XHTML.subclass:
            return ED_NPfIT_Text_XHTML.subclass(*args_, **kwargs_)
        else:
            return ED_NPfIT_Text_XHTML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_html(self): return self.html
    def set_html(self, html): self.html = html
    def hasContent_(self):
        if (
            self.html is not None or
            super(ED_NPfIT_Text_XHTML, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ED.NPfIT.Text.XHTML', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ED.NPfIT.Text.XHTML')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ED.NPfIT.Text.XHTML')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ED.NPfIT.Text.XHTML', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ED.NPfIT.Text.XHTML'):
        super(ED_NPfIT_Text_XHTML, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ED.NPfIT.Text.XHTML')
    def exportChildren(self, outfile, level, namespace_='', name_='ED.NPfIT.Text.XHTML', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.html is not None:
            self.html.export(outfile, level, namespace_, name_='html', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ED_NPfIT_Text_XHTML, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'html':
            obj_ = htmlType.factory()
            obj_.build(child_)
            self.html = obj_
            obj_.original_tagname_ = 'html'


class ST(ED):
    """Data that is primarily intended for human interpretation or for
    further machine processing is outside the scope of HL7. This
    includes unformatted or formatted written language, multimedia
    data, or structured information as defined by a different
    standard (e.g., XML-signatures.) Instead of the data itself, an
    ED may contain only a reference (see TEL.) Note that the ST data
    type is a specialization of the ED data type when the ED media
    type is text/plain. Identifies the type of the encapsulated data
    and identifies a method to interpret or render the data. For
    character based information the language property specifies the
    human language of the text. Indicates whether the raw byte data
    is compressed, and what compression algorithm was used. The
    integrity check is a short binary value representing a
    cryptographically strong checksum that is calculated over the
    binary data. The purpose of this property, when communicated
    with a reference is for anyone to validate later whether the
    reference still resolved to the same data that the reference
    resolved to when the encapsulated data value with reference was
    created. Specifies the algorithm used to compute the
    integrityCheck value."""
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ST, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_,)
        self.mediaType = _cast(None, mediaType)
        self.language = _cast(None, language)
        self.compression = _cast(None, compression)
        self.integrityCheck = _cast(None, integrityCheck)
        self.integrityCheckAlgorithm = _cast(None, integrityCheckAlgorithm)
        self.reference = reference
        self.thumbnail = thumbnail
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ST.subclass:
            return ST.subclass(*args_, **kwargs_)
        else:
            return ST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_thumbnail(self): return self.thumbnail
    def set_thumbnail(self, thumbnail): self.thumbnail = thumbnail
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_mediaType(self): return self.mediaType
    def set_mediaType(self, mediaType): self.mediaType = mediaType
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def get_integrityCheck(self): return self.integrityCheck
    def set_integrityCheck(self, integrityCheck): self.integrityCheck = integrityCheck
    def get_integrityCheckAlgorithm(self): return self.integrityCheckAlgorithm
    def set_integrityCheckAlgorithm(self, integrityCheckAlgorithm): self.integrityCheckAlgorithm = integrityCheckAlgorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_cs_CompressionAlgorithm(self, value):
        # Validate type cs_CompressionAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DF', 'GZ', 'ZL', 'Z']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_CompressionAlgorithm' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_CompressionAlgorithm_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_CompressionAlgorithm_patterns_, ))
    validate_cs_CompressionAlgorithm_patterns_ = [['^[^\\s]*$']]
    def validate_bin(self, value):
        # Validate type bin, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_cs_IntegrityCheckAlgorithm(self, value):
        # Validate type cs_IntegrityCheckAlgorithm, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHA-1', 'SHA-256']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_IntegrityCheckAlgorithm' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_IntegrityCheckAlgorithm_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_IntegrityCheckAlgorithm_patterns_, ))
    validate_cs_IntegrityCheckAlgorithm_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ST, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ST', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ST')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ST', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ST'):
        super(ST, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ST')
        if self.mediaType != "text/plain" and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (quote_attrib(self.mediaType), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (quote_attrib(self.language), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (quote_attrib(self.compression), ))
        if self.integrityCheck is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            outfile.write(' integrityCheck=%s' % (quote_attrib(self.integrityCheck), ))
        if self.integrityCheckAlgorithm != "SHA-1" and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            outfile.write(' integrityCheckAlgorithm=%s' % (quote_attrib(self.integrityCheckAlgorithm), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ST', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            self.reference.export(outfile, level, namespace_, name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            self.thumbnail.export(outfile, level, namespace_, name_='thumbnail', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
            self.validate_cs(self.mediaType)    # validate type cs
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.validate_cs(self.language)    # validate type cs
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
            self.validate_cs_CompressionAlgorithm(self.compression)    # validate type cs_CompressionAlgorithm
        value = find_attr_value_('integrityCheck', node)
        if value is not None and 'integrityCheck' not in already_processed:
            already_processed.add('integrityCheck')
            self.integrityCheck = value
            self.validate_bin(self.integrityCheck)    # validate type bin
        value = find_attr_value_('integrityCheckAlgorithm', node)
        if value is not None and 'integrityCheckAlgorithm' not in already_processed:
            already_processed.add('integrityCheckAlgorithm')
            self.integrityCheckAlgorithm = value
            self.validate_cs_IntegrityCheckAlgorithm(self.integrityCheckAlgorithm)    # validate type cs_IntegrityCheckAlgorithm
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ST, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reference':
            obj_ = TEL.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class ADXP(ST):
    """A character string that may have a type-tag signifying its role in
    the address. Typical parts that exist in about every address are
    street, house number, or post box, postal code, city, country
    but other roles may be defined regionally, nationally, or on an
    enterprise level (e.g. in military addresses). Addresses are
    usually broken up into lines, which are indicated by special
    line-breaking delimiter elements (e.g., DEL). Specifies whether
    an address part names the street, city, country, postal code,
    post box, etc. If the type is NULL the address part is
    unclassified and would simply appear on an address label as is."""
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(ADXP, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADXP.subclass:
            return ADXP.subclass(*args_, **kwargs_)
        else:
            return ADXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ADXP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ADXP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADXP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ADXP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADXP'):
        super(ADXP, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ADXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ADXP', fromsubclass_=False, pretty_print=True):
        super(ADXP, self).exportChildren(outfile, level, namespace_, name_, fromsubclass_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(ADXP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ADXP, self).buildChildren(child_, node, nodeName_, True)
        pass


class additionalLocatorType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(additionalLocatorType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalLocatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalLocatorType.subclass:
            return additionalLocatorType.subclass(*args_, **kwargs_)
        else:
            return additionalLocatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(additionalLocatorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='additionalLocatorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('additionalLocatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='additionalLocatorType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='additionalLocatorType'):
        super(additionalLocatorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='additionalLocatorType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='additionalLocatorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(additionalLocatorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class additionalLocatorType15(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(additionalLocatorType15, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalLocatorType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalLocatorType15.subclass:
            return additionalLocatorType15.subclass(*args_, **kwargs_)
        else:
            return additionalLocatorType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(additionalLocatorType15, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='additionalLocatorType15', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('additionalLocatorType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='additionalLocatorType15')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='additionalLocatorType15'):
        super(additionalLocatorType15, self).exportAttributes(outfile, level, already_processed, namespace_, name_='additionalLocatorType15')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='additionalLocatorType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(additionalLocatorType15, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class carrierType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(carrierType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, carrierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if carrierType.subclass:
            return carrierType.subclass(*args_, **kwargs_)
        else:
            return carrierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(carrierType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='carrierType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('carrierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='carrierType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='carrierType'):
        super(carrierType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='carrierType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='carrierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(carrierType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class carrierType18(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(carrierType18, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, carrierType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if carrierType18.subclass:
            return carrierType18.subclass(*args_, **kwargs_)
        else:
            return carrierType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(carrierType18, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='carrierType18', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('carrierType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='carrierType18')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='carrierType18'):
        super(carrierType18, self).exportAttributes(outfile, level, already_processed, namespace_, name_='carrierType18')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='carrierType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(carrierType18, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class censusTractType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(censusTractType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, censusTractType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if censusTractType.subclass:
            return censusTractType.subclass(*args_, **kwargs_)
        else:
            return censusTractType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(censusTractType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='censusTractType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('censusTractType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='censusTractType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='censusTractType'):
        super(censusTractType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='censusTractType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='censusTractType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(censusTractType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class censusTractType19(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(censusTractType19, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, censusTractType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if censusTractType19.subclass:
            return censusTractType19.subclass(*args_, **kwargs_)
        else:
            return censusTractType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(censusTractType19, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='censusTractType19', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('censusTractType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='censusTractType19')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='censusTractType19'):
        super(censusTractType19, self).exportAttributes(outfile, level, already_processed, namespace_, name_='censusTractType19')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='censusTractType19', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(censusTractType19, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class cityType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(cityType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cityType.subclass:
            return cityType.subclass(*args_, **kwargs_)
        else:
            return cityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(cityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cityType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cityType'):
        super(cityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cityType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(cityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class cityType6(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(cityType6, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cityType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cityType6.subclass:
            return cityType6.subclass(*args_, **kwargs_)
        else:
            return cityType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(cityType6, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cityType6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cityType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cityType6')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cityType6'):
        super(cityType6, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cityType6')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cityType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(cityType6, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class countryType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(countryType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countryType.subclass:
            return countryType.subclass(*args_, **kwargs_)
        else:
            return countryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(countryType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='countryType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('countryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='countryType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='countryType'):
        super(countryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='countryType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='countryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(countryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class countyType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(countyType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countyType.subclass:
            return countyType.subclass(*args_, **kwargs_)
        else:
            return countyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(countyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='countyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('countyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='countyType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='countyType'):
        super(countyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='countyType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='countyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(countyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class countyType5(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(countyType5, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countyType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countyType5.subclass:
            return countyType5.subclass(*args_, **kwargs_)
        else:
            return countyType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(countyType5, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='countyType5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('countyType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='countyType5')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='countyType5'):
        super(countyType5, self).exportAttributes(outfile, level, already_processed, namespace_, name_='countyType5')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='countyType5', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(countyType5, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class delimiterType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(delimiterType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delimiterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delimiterType.subclass:
            return delimiterType.subclass(*args_, **kwargs_)
        else:
            return delimiterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(delimiterType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='delimiterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('delimiterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='delimiterType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='delimiterType'):
        super(delimiterType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='delimiterType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='delimiterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(delimiterType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class delimiterType3(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(delimiterType3, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delimiterType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delimiterType3.subclass:
            return delimiterType3.subclass(*args_, **kwargs_)
        else:
            return delimiterType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(delimiterType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='delimiterType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('delimiterType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='delimiterType3')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='delimiterType3'):
        super(delimiterType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='delimiterType3')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='delimiterType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(delimiterType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class directionType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(directionType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, directionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if directionType.subclass:
            return directionType.subclass(*args_, **kwargs_)
        else:
            return directionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(directionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='directionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('directionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='directionType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='directionType'):
        super(directionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='directionType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='directionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(directionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class directionType11(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(directionType11, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, directionType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if directionType11.subclass:
            return directionType11.subclass(*args_, **kwargs_)
        else:
            return directionType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(directionType11, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='directionType11', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('directionType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='directionType11')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='directionType11'):
        super(directionType11, self).exportAttributes(outfile, level, already_processed, namespace_, name_='directionType11')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='directionType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(directionType11, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class houseNumberNumericType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(houseNumberNumericType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, houseNumberNumericType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if houseNumberNumericType.subclass:
            return houseNumberNumericType.subclass(*args_, **kwargs_)
        else:
            return houseNumberNumericType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(houseNumberNumericType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='houseNumberNumericType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('houseNumberNumericType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberNumericType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='houseNumberNumericType'):
        super(houseNumberNumericType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberNumericType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='houseNumberNumericType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(houseNumberNumericType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class houseNumberNumericType10(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(houseNumberNumericType10, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, houseNumberNumericType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if houseNumberNumericType10.subclass:
            return houseNumberNumericType10.subclass(*args_, **kwargs_)
        else:
            return houseNumberNumericType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(houseNumberNumericType10, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='houseNumberNumericType10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('houseNumberNumericType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberNumericType10')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='houseNumberNumericType10'):
        super(houseNumberNumericType10, self).exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberNumericType10')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='houseNumberNumericType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(houseNumberNumericType10, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class houseNumberType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(houseNumberType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, houseNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if houseNumberType.subclass:
            return houseNumberType.subclass(*args_, **kwargs_)
        else:
            return houseNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(houseNumberType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='houseNumberType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('houseNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='houseNumberType'):
        super(houseNumberType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='houseNumberType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(houseNumberType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class houseNumberType9(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(houseNumberType9, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, houseNumberType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if houseNumberType9.subclass:
            return houseNumberType9.subclass(*args_, **kwargs_)
        else:
            return houseNumberType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(houseNumberType9, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='houseNumberType9', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('houseNumberType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberType9')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='houseNumberType9'):
        super(houseNumberType9, self).exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberType9')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='houseNumberType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(houseNumberType9, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class postalCodeType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(postalCodeType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, postalCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if postalCodeType.subclass:
            return postalCodeType.subclass(*args_, **kwargs_)
        else:
            return postalCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(postalCodeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='postalCodeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('postalCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postalCodeType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='postalCodeType'):
        super(postalCodeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='postalCodeType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='postalCodeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(postalCodeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class postalCodeType7(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(postalCodeType7, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, postalCodeType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if postalCodeType7.subclass:
            return postalCodeType7.subclass(*args_, **kwargs_)
        else:
            return postalCodeType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(postalCodeType7, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='postalCodeType7', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('postalCodeType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postalCodeType7')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='postalCodeType7'):
        super(postalCodeType7, self).exportAttributes(outfile, level, already_processed, namespace_, name_='postalCodeType7')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='postalCodeType7', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(postalCodeType7, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class stateType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(stateType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stateType.subclass:
            return stateType.subclass(*args_, **kwargs_)
        else:
            return stateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='stateType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stateType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stateType'):
        super(stateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='stateType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='stateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(stateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class stateType4(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(stateType4, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stateType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stateType4.subclass:
            return stateType4.subclass(*args_, **kwargs_)
        else:
            return stateType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stateType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='stateType4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stateType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stateType4')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stateType4'):
        super(stateType4, self).exportAttributes(outfile, level, already_processed, namespace_, name_='stateType4')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='stateType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(stateType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetAddressLineType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetAddressLineType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetAddressLineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetAddressLineType.subclass:
            return streetAddressLineType.subclass(*args_, **kwargs_)
        else:
            return streetAddressLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetAddressLineType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetAddressLineType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetAddressLineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressLineType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetAddressLineType'):
        super(streetAddressLineType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressLineType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetAddressLineType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetAddressLineType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetAddressLineType8(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetAddressLineType8, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetAddressLineType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetAddressLineType8.subclass:
            return streetAddressLineType8.subclass(*args_, **kwargs_)
        else:
            return streetAddressLineType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetAddressLineType8, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetAddressLineType8', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetAddressLineType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressLineType8')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetAddressLineType8'):
        super(streetAddressLineType8, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressLineType8')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetAddressLineType8', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetAddressLineType8, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameBaseType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameBaseType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameBaseType.subclass:
            return streetNameBaseType.subclass(*args_, **kwargs_)
        else:
            return streetNameBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameBaseType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameBaseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameBaseType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameBaseType'):
        super(streetNameBaseType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameBaseType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameBaseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameBaseType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameBaseType13(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameBaseType13, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameBaseType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameBaseType13.subclass:
            return streetNameBaseType13.subclass(*args_, **kwargs_)
        else:
            return streetNameBaseType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameBaseType13, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameBaseType13', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameBaseType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameBaseType13')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameBaseType13'):
        super(streetNameBaseType13, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameBaseType13')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameBaseType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameBaseType13, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameType1(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameType1, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameType1.subclass:
            return streetNameType1.subclass(*args_, **kwargs_)
        else:
            return streetNameType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType1')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameType1'):
        super(streetNameType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType1')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameType12(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameType12, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameType12.subclass:
            return streetNameType12.subclass(*args_, **kwargs_)
        else:
            return streetNameType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameType12, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameType12', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType12')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameType12'):
        super(streetNameType12, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType12')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameType12', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameType12, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameTypeType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameTypeType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameTypeType.subclass:
            return streetNameTypeType.subclass(*args_, **kwargs_)
        else:
            return streetNameTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameTypeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameTypeType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameTypeType'):
        super(streetNameTypeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameTypeType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameTypeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameTypeType14(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameTypeType14, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameTypeType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameTypeType14.subclass:
            return streetNameTypeType14.subclass(*args_, **kwargs_)
        else:
            return streetNameTypeType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameTypeType14, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameTypeType14', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameTypeType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameTypeType14')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameTypeType14'):
        super(streetNameTypeType14, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameTypeType14')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameTypeType14', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameTypeType14, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class unitIDType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(unitIDType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitIDType.subclass:
            return unitIDType.subclass(*args_, **kwargs_)
        else:
            return unitIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unitIDType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unitIDType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitIDType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unitIDType'):
        super(unitIDType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unitIDType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unitIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(unitIDType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class unitIDType16(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(unitIDType16, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitIDType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitIDType16.subclass:
            return unitIDType16.subclass(*args_, **kwargs_)
        else:
            return unitIDType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unitIDType16, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unitIDType16', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitIDType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitIDType16')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unitIDType16'):
        super(unitIDType16, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unitIDType16')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unitIDType16', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(unitIDType16, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class unitTypeType(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(unitTypeType, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitTypeType.subclass:
            return unitTypeType.subclass(*args_, **kwargs_)
        else:
            return unitTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unitTypeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unitTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitTypeType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unitTypeType'):
        super(unitTypeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unitTypeType')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unitTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(unitTypeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class unitTypeType17(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(unitTypeType17, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitTypeType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitTypeType17.subclass:
            return unitTypeType17.subclass(*args_, **kwargs_)
        else:
            return unitTypeType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unitTypeType17, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unitTypeType17', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitTypeType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitTypeType17')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unitTypeType17'):
        super(unitTypeType17, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unitTypeType17')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unitTypeType17', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(unitTypeType17, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class ADXP_NPfIT_NotAny(ST):
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ADXP_NPfIT_NotAny, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_, extensiontype_, )
        self.reference = reference
        self.thumbnail = thumbnail
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADXP_NPfIT_NotAny)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADXP_NPfIT_NotAny.subclass:
            return ADXP_NPfIT_NotAny.subclass(*args_, **kwargs_)
        else:
            return ADXP_NPfIT_NotAny(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_thumbnail(self): return self.thumbnail
    def set_thumbnail(self, thumbnail): self.thumbnail = thumbnail
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ADXP_NPfIT_NotAny, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ADXP.NPfIT.NotAny', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADXP.NPfIT.NotAny')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADXP.NPfIT.NotAny')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ADXP.NPfIT.NotAny', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADXP.NPfIT.NotAny'):
        super(ADXP_NPfIT_NotAny, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ADXP.NPfIT.NotAny')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ADXP.NPfIT.NotAny', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            self.reference.export(outfile, level, namespace_, name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            self.thumbnail.export(outfile, level, namespace_, name_='thumbnail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ADXP_NPfIT_NotAny, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reference':
            obj_ = TEL.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'reference', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_reference'):
              self.add_reference(obj_.value)
            elif hasattr(self, 'set_reference'):
              self.set_reference(obj_.value)
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'thumbnail', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_thumbnail'):
              self.add_thumbnail(obj_.value)
            elif hasattr(self, 'set_thumbnail'):
              self.set_thumbnail(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class ADXP_NPfIT_Coded(ADXP_NPfIT_NotAny):
    subclass = None
    superclass = ADXP_NPfIT_NotAny
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, code=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(ADXP_NPfIT_Coded, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.code = code
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADXP_NPfIT_Coded)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADXP_NPfIT_Coded.subclass:
            return ADXP_NPfIT_Coded.subclass(*args_, **kwargs_)
        else:
            return ADXP_NPfIT_Coded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.code is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ADXP_NPfIT_Coded, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ADXP.NPfIT.Coded', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADXP.NPfIT.Coded')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADXP.NPfIT.Coded')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ADXP.NPfIT.Coded', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADXP.NPfIT.Coded'):
        super(ADXP_NPfIT_Coded, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ADXP.NPfIT.Coded')
    def exportChildren(self, outfile, level, namespace_='', name_='ADXP.NPfIT.Coded', fromsubclass_=False, pretty_print=True):
        super(ADXP_NPfIT_Coded, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            self.code.export(outfile, level, namespace_, name_='code', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ADXP_NPfIT_Coded, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            class_obj_ = self.get_class_obj_(child_, CV)
            class_obj_ = CV.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'code', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_code'):
              self.add_code(obj_.value)
            elif hasattr(self, 'set_code'):
              self.set_code(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ADXP_NPfIT_Coded, self).buildChildren(child_, node, nodeName_, True)


class ENXP(ST):
    """A character string token representing a part of a name. May have a
    type code signifying the role of the part in the whole entity
    name, and a qualifier code for more detail about the name part
    type. Typical name parts for person names are given names, and
    family names, titles, etc. Indicates whether the name part is a
    given name, family name, prefix, suffix, etc. The qualifier is a
    set of codes each of which specifies a certain subcategory of
    the name part in addition to the main name part type. For
    example, a given name may be flagged as a nickname, a family
    name may be a pseudonym or a name of public records."""
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(ENXP, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.qualifier = _cast(None, qualifier)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENXP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENXP.subclass:
            return ENXP.subclass(*args_, **kwargs_)
        else:
            return ENXP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_EntityNamePartType(self, value):
        # Validate type cs_EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAM', 'GIV', 'PFX', 'SFX', 'DEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_EntityNamePartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_EntityNamePartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_EntityNamePartType_patterns_, ))
    validate_cs_EntityNamePartType_patterns_ = [['^[^\\s]*$']]
    def validate_set_cs_EntityNamePartQualifier(self, value):
        # Validate type set_cs_EntityNamePartQualifier, a restriction on cs_EntityNamePartQualifier.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ENXP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENXP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENXP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENXP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENXP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENXP'):
        super(ENXP, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ENXP')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (quote_attrib(self.qualifier), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ENXP', fromsubclass_=False, pretty_print=True):
        super(ENXP, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_EntityNamePartType(self.partType)    # validate type cs_EntityNamePartType
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
            self.validate_set_cs_EntityNamePartQualifier(self.qualifier)    # validate type set_cs_EntityNamePartQualifier
        super(ENXP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ENXP, self).buildChildren(child_, node, nodeName_, True)
        pass


class en_delimiter(ENXP):
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(en_delimiter, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_delimiter.subclass:
            return en_delimiter.subclass(*args_, **kwargs_)
        else:
            return en_delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_EntityNamePartType(self, value):
        # Validate type cs_EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAM', 'GIV', 'PFX', 'SFX', 'DEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_EntityNamePartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_EntityNamePartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_EntityNamePartType_patterns_, ))
    validate_cs_EntityNamePartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(en_delimiter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='en.delimiter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='en.delimiter')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='en.delimiter'):
        super(en_delimiter, self).exportAttributes(outfile, level, already_processed, namespace_, name_='en.delimiter')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='en.delimiter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_EntityNamePartType(self.partType)    # validate type cs_EntityNamePartType
        super(en_delimiter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class en_family(ENXP):
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(en_family, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_family)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_family.subclass:
            return en_family.subclass(*args_, **kwargs_)
        else:
            return en_family(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_EntityNamePartType(self, value):
        # Validate type cs_EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAM', 'GIV', 'PFX', 'SFX', 'DEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_EntityNamePartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_EntityNamePartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_EntityNamePartType_patterns_, ))
    validate_cs_EntityNamePartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(en_family, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='en.family', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.family')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='en.family')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='en.family'):
        super(en_family, self).exportAttributes(outfile, level, already_processed, namespace_, name_='en.family')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='en.family', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_EntityNamePartType(self.partType)    # validate type cs_EntityNamePartType
        super(en_family, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class en_given(ENXP):
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(en_given, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_given)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_given.subclass:
            return en_given.subclass(*args_, **kwargs_)
        else:
            return en_given(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_EntityNamePartType(self, value):
        # Validate type cs_EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAM', 'GIV', 'PFX', 'SFX', 'DEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_EntityNamePartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_EntityNamePartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_EntityNamePartType_patterns_, ))
    validate_cs_EntityNamePartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(en_given, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='en.given', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.given')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='en.given')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='en.given'):
        super(en_given, self).exportAttributes(outfile, level, already_processed, namespace_, name_='en.given')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='en.given', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_EntityNamePartType(self.partType)    # validate type cs_EntityNamePartType
        super(en_given, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class en_prefix(ENXP):
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(en_prefix, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_prefix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_prefix.subclass:
            return en_prefix.subclass(*args_, **kwargs_)
        else:
            return en_prefix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_EntityNamePartType(self, value):
        # Validate type cs_EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAM', 'GIV', 'PFX', 'SFX', 'DEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_EntityNamePartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_EntityNamePartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_EntityNamePartType_patterns_, ))
    validate_cs_EntityNamePartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(en_prefix, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='en.prefix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.prefix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='en.prefix')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='en.prefix'):
        super(en_prefix, self).exportAttributes(outfile, level, already_processed, namespace_, name_='en.prefix')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='en.prefix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_EntityNamePartType(self.partType)    # validate type cs_EntityNamePartType
        super(en_prefix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class en_suffix(ENXP):
    subclass = None
    superclass = ENXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, qualifier=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(en_suffix, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, qualifier, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, en_suffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if en_suffix.subclass:
            return en_suffix.subclass(*args_, **kwargs_)
        else:
            return en_suffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_EntityNamePartType(self, value):
        # Validate type cs_EntityNamePartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAM', 'GIV', 'PFX', 'SFX', 'DEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_EntityNamePartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_EntityNamePartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_EntityNamePartType_patterns_, ))
    validate_cs_EntityNamePartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(en_suffix, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='en.suffix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('en.suffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='en.suffix')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='en.suffix'):
        super(en_suffix, self).exportAttributes(outfile, level, already_processed, namespace_, name_='en.suffix')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='en.suffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_EntityNamePartType(self.partType)    # validate type cs_EntityNamePartType
        super(en_suffix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class SC(ST):
    """A Character String that optionally may have a code attached. The
    text must always be present if a code is present. The code is
    often a local code. The plain code symbol defined by the code
    system. For example, "784.0" is the code symbol of the ICD-9
    code "784.0" for headache. Specifies the code system that
    defines the code. A common name of the coding system. If
    applicable, a version descriptor defined specifically for the
    given code system. A name or title for the code, under which the
    sending system shows the code value to its users."""
    subclass = None
    superclass = ST
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(SC, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SC.subclass:
            return SC.subclass(*args_, **kwargs_)
        else:
            return SC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SC', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SC'):
        super(SC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SC')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SC', fromsubclass_=False, pretty_print=True):
        super(SC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(SC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SC, self).buildChildren(child_, node, nodeName_, True)
        pass


class thumbnail(ED):
    """A thumbnail is an abbreviated rendition of the full data. A
    thumbnail requires significantly fewer resources than the full
    data, while still maintaining some distinctive similarity with
    the full data. A thumbnail is typically used with by-reference
    encapsulated data. It allows a user to select data more
    efficiently before actually downloading through the reference."""
    subclass = None
    superclass = ED
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, thumbnail_member=None):
        self.original_tagname_ = None
        super(thumbnail, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, )
        self.reference = reference
        self.thumbnail = thumbnail_member
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, thumbnail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if thumbnail.subclass:
            return thumbnail.subclass(*args_, **kwargs_)
        else:
            return thumbnail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_thumbnail(self): return self.thumbnail
    def set_thumbnail(self, thumbnail): self.thumbnail = thumbnail
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.reference is not None or
            self.thumbnail is not None or
            self.anytypeobjs_ or
            super(thumbnail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='thumbnail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('thumbnail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='thumbnail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='thumbnail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='thumbnail'):
        super(thumbnail, self).exportAttributes(outfile, level, already_processed, namespace_, name_='thumbnail')
    def exportChildren(self, outfile, level, namespace_='', name_='thumbnail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            self.reference.export(outfile, level, namespace_, name_='reference', pretty_print=pretty_print)
        if self.thumbnail is not None:
            self.thumbnail.export(outfile, level, namespace_, name_='thumbnail', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(thumbnail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reference':
            obj_ = TEL.factory()
            obj_.build(child_)
            self.reference = obj_
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'thumbnail':
            obj_ = thumbnail.factory()
            obj_.build(child_)
            self.thumbnail = obj_
            obj_.original_tagname_ = 'thumbnail'
        else:
            obj_ = self.gds_build_any(child_, 'thumbnail')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)


class BL(ANY):
    """The Boolean type stands for the values of two-valued logic. A
    Boolean value can be either true or false, or, as any other
    value may be NULL."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, value=None):
        self.original_tagname_ = None
        super(BL, self).__init__(nullFlavor, updateMode, )
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BL.subclass:
            return BL.subclass(*args_, **kwargs_)
        else:
            return BL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            super(BL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BL'):
        super(BL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BL', fromsubclass_=False, pretty_print=True):
        super(BL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_bl(self.value)    # validate type bl
        super(BL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BL, self).buildChildren(child_, node, nodeName_, True)
        pass


class BN(ANY):
    """The Boolean type stands for the values of two-valued logic. A
    Boolean value can be either true or false, or, as any other
    value may be NULL."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, value=None):
        self.original_tagname_ = None
        super(BN, self).__init__(nullFlavor, updateMode, )
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BN.subclass:
            return BN.subclass(*args_, **kwargs_)
        else:
            return BN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            super(BN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BN'):
        super(BN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BN')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BN', fromsubclass_=False, pretty_print=True):
        super(BN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_bl(self.value)    # validate type bl
        super(BN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BN, self).buildChildren(child_, node, nodeName_, True)
        pass


class CD(ANY):
    """A concept descriptor represents any kind of concept usually by
    giving a code defined in a code system. A concept descriptor can
    contain the original text or phrase that served as the basis of
    the coding and one or more translations into different coding
    systems. A concept descriptor can also contain qualifiers to
    describe, e.g., the concept of a "left foot" as a
    postcoordinated term built from the primary code "FOOT" and the
    qualifier "LEFT". In exceptional cases, the concept descriptor
    need not contain a code but only the original text describing
    that concept. The plain code symbol defined by the code system.
    For example, "784.0" is the code symbol of the ICD-9 code
    "784.0" for headache. Specifies the code system that defines the
    code. A common name of the coding system. If applicable, a
    version descriptor defined specifically for the given code
    system. A name or title for the code, under which the sending
    system shows the code value to its users."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CD, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.originalText = originalText
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        if group is None:
            self.group = []
        else:
            self.group = group
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CD.subclass:
            return CD.subclass(*args_, **kwargs_)
        else:
            return CD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalText(self): return self.originalText
    def set_originalText(self, originalText): self.originalText = originalText
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def add_qualifier(self, value): self.qualifier.append(value)
    def insert_qualifier_at(self, index, value): self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value): self.qualifier[index] = value
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def add_translation(self, value): self.translation.append(value)
    def insert_translation_at(self, index, value): self.translation.insert(index, value)
    def replace_translation_at(self, index, value): self.translation[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.qualifier or
            self.group or
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CD', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CD'):
        super(CD, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CD')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CD', fromsubclass_=False, pretty_print=True):
        super(CD, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            self.originalText.export(outfile, level, namespace_, name_='originalText', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            qualifier_.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
        for translation_ in self.translation:
            translation_.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalText':
            obj_ = ED.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'originalText', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_originalText'):
              self.add_originalText(obj_.value)
            elif hasattr(self, 'set_originalText'):
              self.set_originalText(obj_.value)
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'qualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_qualifier'):
              self.add_qualifier(obj_.value)
            elif hasattr(self, 'set_qualifier'):
              self.set_qualifier(obj_.value)
        elif nodeName_ == 'group':
            obj_ = groupType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'group', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_group'):
              self.add_group(obj_.value)
            elif hasattr(self, 'set_group'):
              self.set_group(obj_.value)
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            class_obj_ = CD.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CD, self).buildChildren(child_, node, nodeName_, True)


class CE(CD):
    """Coded data, consists of a coded value (CV) and, optionally, coded
    value(s) from other coding systems that identify the same
    concept. Used when alternative codes may exist. The plain code
    symbol defined by the code system. For example, "784.0" is the
    code symbol of the ICD-9 code "784.0" for headache. Specifies
    the code system that defines the code. A common name of the
    coding system. If applicable, a version descriptor defined
    specifically for the given code system. A name or title for the
    code, under which the sending system shows the code value to its
    users."""
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(CE, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.qualifier = qualifier
        self.originalText = originalText
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CE.subclass:
            return CE.subclass(*args_, **kwargs_)
        else:
            return CE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_originalText(self): return self.originalText
    def set_originalText(self, originalText): self.originalText = originalText
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def add_translation(self, value): self.translation.append(value)
    def insert_translation_at(self, index, value): self.translation.insert(index, value)
    def replace_translation_at(self, index, value): self.translation[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.qualifier is not None or
            self.originalText is not None or
            self.translation or
            super(CE, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CE'):
        super(CE, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CE')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qualifier is not None:
            self.qualifier.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
        if self.originalText is not None:
            self.originalText.export(outfile, level, namespace_, name_='originalText', pretty_print=pretty_print)
        for translation_ in self.translation:
            translation_.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CE, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'originalText':
            obj_ = ED.factory()
            obj_.build(child_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.translation.append(obj_)
            obj_.original_tagname_ = 'translation'


class CV(CE):
    """Coded data, consists of a code, display name, code system, and
    original text. Used when a single code value must be sent. The
    plain code symbol defined by the code system. For example,
    "784.0" is the code symbol of the ICD-9 code "784.0" for
    headache. Specifies the code system that defines the code. A
    common name of the coding system. If applicable, a version
    descriptor defined specifically for the given code system. A
    name or title for the code, under which the sending system shows
    the code value to its users."""
    subclass = None
    superclass = CE
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CV, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.originalText = originalText
        self.translation = translation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV.subclass:
            return CV.subclass(*args_, **kwargs_)
        else:
            return CV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalText(self): return self.originalText
    def set_originalText(self, originalText): self.originalText = originalText
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.translation is not None or
            super(CV, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CV'):
        super(CV, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CV')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            self.originalText.export(outfile, level, namespace_, name_='originalText', pretty_print=pretty_print)
        if self.translation is not None:
            self.translation.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CV, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalText':
            obj_ = ED.factory()
            obj_.build(child_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.translation = obj_
            obj_.original_tagname_ = 'translation'


class CO(CV):
    """Coded data, where the domain from which the codeset comes is
    ordered. The Coded Ordinal data type adds semantics related to
    ordering so that models that make use of such domains may
    introduce model elements that involve statements about the order
    of the terms in a domain. The representation is exactly the same
    as CV, but the type still needs to be defined."""
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(CO, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CO.subclass:
            return CO.subclass(*args_, **kwargs_)
        else:
            return CO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CO', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CO'):
        super(CO, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CO')
    def exportChildren(self, outfile, level, namespace_='', name_='CO', fromsubclass_=False, pretty_print=True):
        super(CO, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CO, self).buildChildren(child_, node, nodeName_, True)
        pass


class CS(CV):
    """Coded data, consists of a code, display name, code system, and
    original text. Used when a single code value must be sent. The
    plain code symbol defined by the code system. For example,
    "784.0" is the code symbol of the ICD-9 code "784.0" for
    headache."""
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(CS, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CS.subclass:
            return CS.subclass(*args_, **kwargs_)
        else:
            return CS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(CS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CS'):
        super(CS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CS')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class CV_NHS_CodedValueType1(CV):
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(CV_NHS_CodedValueType1, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV_NHS_CodedValueType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV_NHS_CodedValueType1.subclass:
            return CV_NHS_CodedValueType1.subclass(*args_, **kwargs_)
        else:
            return CV_NHS_CodedValueType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            super(CV_NHS_CodedValueType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CV.NHS.CodedValueType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV.NHS.CodedValueType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CV.NHS.CodedValueType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CV.NHS.CodedValueType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CV.NHS.CodedValueType1'):
        super(CV_NHS_CodedValueType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CV.NHS.CodedValueType1')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CV.NHS.CodedValueType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        super(CV_NHS_CodedValueType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class administrativeGenderCodeType(CV_NHS_CodedValueType1):
    subclass = None
    superclass = CV_NHS_CodedValueType1
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(administrativeGenderCodeType, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, administrativeGenderCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if administrativeGenderCodeType.subclass:
            return administrativeGenderCodeType.subclass(*args_, **kwargs_)
        else:
            return administrativeGenderCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(administrativeGenderCodeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='administrativeGenderCodeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('administrativeGenderCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='administrativeGenderCodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='administrativeGenderCodeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='administrativeGenderCodeType'):
        super(administrativeGenderCodeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='administrativeGenderCodeType')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
    def exportChildren(self, outfile, level, namespace_='', name_='administrativeGenderCodeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        super(administrativeGenderCodeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class codeType(CV_NHS_CodedValueType1):
    subclass = None
    superclass = CV_NHS_CodedValueType1
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(codeType, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codeType.subclass:
            return codeType.subclass(*args_, **kwargs_)
        else:
            return codeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(codeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codeType'):
        super(codeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='codeType')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
    def exportChildren(self, outfile, level, namespace_='', name_='codeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        super(codeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class valueType(CV_NHS_CodedValueType1):
    subclass = None
    superclass = CV_NHS_CodedValueType1
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(valueType, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueType.subclass:
            return valueType.subclass(*args_, **kwargs_)
        else:
            return valueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(valueType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='valueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='valueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='valueType'):
        super(valueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='valueType')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
    def exportChildren(self, outfile, level, namespace_='', name_='valueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        super(valueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class PQR(CV):
    """A representation of a physical quantity in a unit from any code
    system. Used to show alternative representation for a physical
    quantity. The magnitude of the measurement value in terms of the
    unit specified in the code."""
    subclass = None
    superclass = CV
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None, value=None):
        self.original_tagname_ = None
        super(PQR, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQR.subclass:
            return PQR.subclass(*args_, **kwargs_)
        else:
            return PQR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(PQR, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PQR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PQR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PQR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PQR'):
        super(PQR, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PQR')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PQR', fromsubclass_=False, pretty_print=True):
        super(PQR, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        super(PQR, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PQR, self).buildChildren(child_, node, nodeName_, True)
        pass


class CR(CD):
    """A concept qualifier code with optionally named role. Both qualifier
    role and value codes must be defined by the coding system. For
    example, if SNOMED RT defines a concept "leg", a role relation
    "has-laterality", and another concept "left", the concept role
    relation allows to add the qualifier "has-laterality: left" to a
    primary code "leg" to construct the meaning "left leg".
    Indicates if the sense of the role name is inverted. This can be
    used in cases where the underlying code system defines inversion
    but does not provide reciprocal pairs of role names. By default,
    inverted is false."""
    subclass = None
    superclass = CD
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None, inverted='false', name=None, value=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(CR, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, valueOf_, mixedclass_, content_, )
        self.inverted = _cast(None, inverted)
        self.name = name
        self.value = value
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CR.subclass:
            return CR.subclass(*args_, **kwargs_)
        else:
            return CR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_inverted(self): return self.inverted
    def set_inverted(self, inverted): self.inverted = inverted
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CR, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CR'):
        super(CR, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CR')
        if self.inverted != "false" and 'inverted' not in already_processed:
            already_processed.add('inverted')
            outfile.write(' inverted=%s' % (quote_attrib(self.inverted), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CR', fromsubclass_=False, pretty_print=True):
        super(CR, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inverted', node)
        if value is not None and 'inverted' not in already_processed:
            already_processed.add('inverted')
            self.inverted = value
            self.validate_bl(self.inverted)    # validate type bl
        super(CR, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, CV)
            class_obj_ = CV.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'name', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_name'):
              self.add_name(obj_.value)
            elif hasattr(self, 'set_name'):
              self.set_name(obj_.value)
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, CD)
            class_obj_ = CD.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'value', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_value'):
              self.add_value(obj_.value)
            elif hasattr(self, 'set_value'):
              self.set_value(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CR, self).buildChildren(child_, node, nodeName_, True)


class CD_NPfIT_CDA_Url(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(CD_NPfIT_CDA_Url, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.originalText = originalText
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        if group is None:
            self.group = []
        else:
            self.group = group
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CD_NPfIT_CDA_Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CD_NPfIT_CDA_Url.subclass:
            return CD_NPfIT_CDA_Url.subclass(*args_, **kwargs_)
        else:
            return CD_NPfIT_CDA_Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalText(self): return self.originalText
    def set_originalText(self, originalText): self.originalText = originalText
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def add_qualifier(self, value): self.qualifier.append(value)
    def insert_qualifier_at(self, index, value): self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value): self.qualifier[index] = value
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def add_translation(self, value): self.translation.append(value)
    def insert_translation_at(self, index, value): self.translation.insert(index, value)
    def replace_translation_at(self, index, value): self.translation[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.qualifier or
            self.group or
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CD_NPfIT_CDA_Url, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CD.NPfIT.CDA.Url', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CD.NPfIT.CDA.Url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CD.NPfIT.CDA.Url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CD.NPfIT.CDA.Url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CD.NPfIT.CDA.Url'):
        super(CD_NPfIT_CDA_Url, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CD.NPfIT.CDA.Url')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CD.NPfIT.CDA.Url', fromsubclass_=False, pretty_print=True):
        super(CD_NPfIT_CDA_Url, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            self.originalText.export(outfile, level, namespace_, name_='originalText', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            qualifier_.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
        for translation_ in self.translation:
            translation_.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CD_NPfIT_CDA_Url, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalText':
            obj_ = Cda_NPfIT_ED.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'originalText', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_originalText'):
              self.add_originalText(obj_.value)
            elif hasattr(self, 'set_originalText'):
              self.set_originalText(obj_.value)
        elif nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'qualifier', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_qualifier'):
              self.add_qualifier(obj_.value)
            elif hasattr(self, 'set_qualifier'):
              self.set_qualifier(obj_.value)
        elif nodeName_ == 'group':
            obj_ = groupType22.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'group', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_group'):
              self.add_group(obj_.value)
            elif hasattr(self, 'set_group'):
              self.set_group(obj_.value)
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            class_obj_ = CD.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(CD_NPfIT_CDA_Url, self).buildChildren(child_, node, nodeName_, True)


class CE_NPfIT_CDA_Url(CD_NPfIT_CDA_Url):
    subclass = None
    superclass = CD_NPfIT_CDA_Url
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(CE_NPfIT_CDA_Url, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.qualifier = qualifier
        self.originalText = originalText
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CE_NPfIT_CDA_Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CE_NPfIT_CDA_Url.subclass:
            return CE_NPfIT_CDA_Url.subclass(*args_, **kwargs_)
        else:
            return CE_NPfIT_CDA_Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_originalText(self): return self.originalText
    def set_originalText(self, originalText): self.originalText = originalText
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def add_translation(self, value): self.translation.append(value)
    def insert_translation_at(self, index, value): self.translation.insert(index, value)
    def replace_translation_at(self, index, value): self.translation[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.qualifier is not None or
            self.originalText is not None or
            self.translation or
            super(CE_NPfIT_CDA_Url, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CE.NPfIT.CDA.Url', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CE.NPfIT.CDA.Url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CE.NPfIT.CDA.Url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CE.NPfIT.CDA.Url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CE.NPfIT.CDA.Url'):
        super(CE_NPfIT_CDA_Url, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CE.NPfIT.CDA.Url')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CE.NPfIT.CDA.Url', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qualifier is not None:
            self.qualifier.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
        if self.originalText is not None:
            self.originalText.export(outfile, level, namespace_, name_='originalText', pretty_print=pretty_print)
        for translation_ in self.translation:
            translation_.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CE_NPfIT_CDA_Url, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'originalText':
            obj_ = Cda_NPfIT_ED.factory()
            obj_.build(child_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.translation.append(obj_)
            obj_.original_tagname_ = 'translation'


class CV_NPfIT_CDA_Url(CE_NPfIT_CDA_Url):
    subclass = None
    superclass = CE_NPfIT_CDA_Url
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(CV_NPfIT_CDA_Url, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
        self.codeSystemName = _cast(None, codeSystemName)
        self.codeSystemVersion = _cast(None, codeSystemVersion)
        self.displayName = _cast(None, displayName)
        self.originalText = originalText
        self.translation = translation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV_NPfIT_CDA_Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV_NPfIT_CDA_Url.subclass:
            return CV_NPfIT_CDA_Url.subclass(*args_, **kwargs_)
        else:
            return CV_NPfIT_CDA_Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originalText(self): return self.originalText
    def set_originalText(self, originalText): self.originalText = originalText
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def get_codeSystemName(self): return self.codeSystemName
    def set_codeSystemName(self, codeSystemName): self.codeSystemName = codeSystemName
    def get_codeSystemVersion(self): return self.codeSystemVersion
    def set_codeSystemVersion(self, codeSystemVersion): self.codeSystemVersion = codeSystemVersion
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.originalText is not None or
            self.translation is not None or
            super(CV_NPfIT_CDA_Url, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CV.NPfIT.CDA.Url', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV.NPfIT.CDA.Url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CV.NPfIT.CDA.Url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CV.NPfIT.CDA.Url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CV.NPfIT.CDA.Url'):
        super(CV_NPfIT_CDA_Url, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CV.NPfIT.CDA.Url')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
        if self.codeSystemName is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            outfile.write(' codeSystemName=%s' % (quote_attrib(self.codeSystemName), ))
        if self.codeSystemVersion is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            outfile.write(' codeSystemVersion=%s' % (quote_attrib(self.codeSystemVersion), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (quote_attrib(self.displayName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CV.NPfIT.CDA.Url', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalText is not None:
            self.originalText.export(outfile, level, namespace_, name_='originalText', pretty_print=pretty_print)
        if self.translation is not None:
            self.translation.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        value = find_attr_value_('codeSystemName', node)
        if value is not None and 'codeSystemName' not in already_processed:
            already_processed.add('codeSystemName')
            self.codeSystemName = value
            self.validate_st(self.codeSystemName)    # validate type st
        value = find_attr_value_('codeSystemVersion', node)
        if value is not None and 'codeSystemVersion' not in already_processed:
            already_processed.add('codeSystemVersion')
            self.codeSystemVersion = value
            self.validate_st(self.codeSystemVersion)    # validate type st
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
            self.validate_st(self.displayName)    # validate type st
        super(CV_NPfIT_CDA_Url, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originalText':
            obj_ = Cda_NPfIT_ED.factory()
            obj_.build(child_)
            self.originalText = obj_
            obj_.original_tagname_ = 'originalText'
        elif nodeName_ == 'translation':
            class_obj_ = self.get_class_obj_(child_, CD)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.translation = obj_
            obj_.original_tagname_ = 'translation'


class Cda_NPfIT_Url(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(Cda_NPfIT_Url, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cda_NPfIT_Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cda_NPfIT_Url.subclass:
            return Cda_NPfIT_Url.subclass(*args_, **kwargs_)
        else:
            return Cda_NPfIT_Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cda_NPfIT_url(self, value):
        # Validate type cda.NPfIT.url, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Cda_NPfIT_Url, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cda.NPfIT.Url', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cda.NPfIT.Url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cda.NPfIT.Url')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cda.NPfIT.Url'):
        super(Cda_NPfIT_Url, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cda.NPfIT.Url')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Cda.NPfIT.Url', fromsubclass_=False, pretty_print=True):
        super(Cda_NPfIT_Url, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_cda_NPfIT_url(self.value)    # validate type cda.NPfIT.url
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Cda_NPfIT_Url, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Cda_NPfIT_Url, self).buildChildren(child_, node, nodeName_, True)
        pass


class Any_NPfIT_Url(Cda_NPfIT_Url):
    subclass = None
    superclass = Cda_NPfIT_Url
    def __init__(self, nullFlavor=None, updateMode=None, value=None, use=None, useablePeriod=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(Any_NPfIT_Url, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.id = id
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Any_NPfIT_Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Any_NPfIT_Url.subclass:
            return Any_NPfIT_Url.subclass(*args_, **kwargs_)
        else:
            return Any_NPfIT_Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_useablePeriod(self): return self.useablePeriod
    def set_useablePeriod(self, useablePeriod): self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value): self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value): self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value): self.useablePeriod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_TelecommunicationAddressUse(self, value):
        # Validate type set_cs_TelecommunicationAddressUse, a restriction on cs_TelecommunicationAddressUse.
        pass
    def hasContent_(self):
        if (
            self.useablePeriod or
            self.id is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Any_NPfIT_Url, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Any.NPfIT.Url', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Any.NPfIT.Url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Any.NPfIT.Url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Any.NPfIT.Url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Any.NPfIT.Url'):
        super(Any_NPfIT_Url, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Any.NPfIT.Url')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Any.NPfIT.Url', fromsubclass_=False, pretty_print=True):
        super(Any_NPfIT_Url, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for useablePeriod_ in self.useablePeriod:
            useablePeriod_.export(outfile, level, namespace_, name_='useablePeriod', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_TelecommunicationAddressUse(self.use)    # validate type set_cs_TelecommunicationAddressUse
        super(Any_NPfIT_Url, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'useablePeriod':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'id', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_id'):
              self.add_id(obj_.value)
            elif hasattr(self, 'set_id'):
              self.set_id(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Any_NPfIT_Url, self).buildChildren(child_, node, nodeName_, True)


class EN(ANY):
    """A name for a person, organization, place or thing. A sequence of
    name parts, such as given name or family name, prefix, suffix,
    etc. Examples for entity name values are "Jim Bob Walton, Jr.",
    "Health Level Seven, Inc.", "Lake Tahoe", etc. An entity name
    may be as simple as a character string or may consist of several
    entity name parts, such as, "Jim", "Bob", "Walton", and "Jr.",
    "Health Level Seven" and "Inc.", "Lake" and "Tahoe". A set of
    codes advising a system or user which name in a set of like
    names to select for a given purpose. A name without specific use
    code might be a default name useful for any purpose, but a name
    with a specific use code would be preferred for that respective
    purpose."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, id=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(EN, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.use = _cast(None, use)
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        if family is None:
            self.family = []
        else:
            self.family = family
        if given is None:
            self.given = []
        else:
            self.given = given
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.validTime = validTime
        self.id = id
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EN.subclass:
            return EN.subclass(*args_, **kwargs_)
        else:
            return EN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def add_delimiter(self, value): self.delimiter.append(value)
    def insert_delimiter_at(self, index, value): self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value): self.delimiter[index] = value
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def add_family(self, value): self.family.append(value)
    def insert_family_at(self, index, value): self.family.insert(index, value)
    def replace_family_at(self, index, value): self.family[index] = value
    def get_given(self): return self.given
    def set_given(self, given): self.given = given
    def add_given(self, value): self.given.append(value)
    def insert_given_at(self, index, value): self.given.insert(index, value)
    def replace_given_at(self, index, value): self.given[index] = value
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def add_prefix(self, value): self.prefix.append(value)
    def insert_prefix_at(self, index, value): self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value): self.prefix[index] = value
    def get_suffix(self): return self.suffix
    def set_suffix(self, suffix): self.suffix = suffix
    def add_suffix(self, value): self.suffix.append(value)
    def insert_suffix_at(self, index, value): self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value): self.suffix[index] = value
    def get_validTime(self): return self.validTime
    def set_validTime(self, validTime): self.validTime = validTime
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_set_cs_EntityNameUse(self, value):
        # Validate type set_cs_EntityNameUse, a restriction on cs_EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.delimiter or
            self.family or
            self.given or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            self.id is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EN'):
        super(EN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EN')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EN', fromsubclass_=False, pretty_print=True):
        super(EN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            delimiter_.export(outfile, level, namespace_, name_='delimiter', pretty_print=pretty_print)
        for family_ in self.family:
            family_.export(outfile, level, namespace_, name_='family', pretty_print=pretty_print)
        for given_ in self.given:
            given_.export(outfile, level, namespace_, name_='given', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            prefix_.export(outfile, level, namespace_, name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            suffix_.export(outfile, level, namespace_, name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            self.validTime.export(outfile, level, namespace_, name_='validTime', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_EntityNameUse(self.use)    # validate type set_cs_EntityNameUse
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        elif nodeName_ == 'given':
            obj_ = en_given.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'id', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_id'):
              self.add_id(obj_.value)
            elif hasattr(self, 'set_id'):
              self.set_id(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EN, self).buildChildren(child_, node, nodeName_, True)


class ON(EN):
    """A name for an organization. A sequence of name parts. A set of codes
    advising a system or user which name in a set of like names to
    select for a given purpose. A name without specific use code
    might be a default name useful for any purpose, but a name with
    a specific use code would be preferred for that respective
    purpose."""
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor=None, updateMode=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(ON, self).__init__(nullFlavor, updateMode, use, delimiter, family, given, prefix, suffix, validTime, id, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        if delimiter is None:
            self.delimiter = []
        else:
            self.delimiter = delimiter
        if prefix is None:
            self.prefix = []
        else:
            self.prefix = prefix
        if suffix is None:
            self.suffix = []
        else:
            self.suffix = suffix
        self.validTime = validTime
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ON)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ON.subclass:
            return ON.subclass(*args_, **kwargs_)
        else:
            return ON(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def add_delimiter(self, value): self.delimiter.append(value)
    def insert_delimiter_at(self, index, value): self.delimiter.insert(index, value)
    def replace_delimiter_at(self, index, value): self.delimiter[index] = value
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def add_prefix(self, value): self.prefix.append(value)
    def insert_prefix_at(self, index, value): self.prefix.insert(index, value)
    def replace_prefix_at(self, index, value): self.prefix[index] = value
    def get_suffix(self): return self.suffix
    def set_suffix(self, suffix): self.suffix = suffix
    def add_suffix(self, value): self.suffix.append(value)
    def insert_suffix_at(self, index, value): self.suffix.insert(index, value)
    def replace_suffix_at(self, index, value): self.suffix[index] = value
    def get_validTime(self): return self.validTime
    def set_validTime(self, validTime): self.validTime = validTime
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_EntityNameUse(self, value):
        # Validate type set_cs_EntityNameUse, a restriction on cs_EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.delimiter or
            self.prefix or
            self.suffix or
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ON, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ON', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ON')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ON')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ON', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ON'):
        super(ON, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ON')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ON', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for delimiter_ in self.delimiter:
            delimiter_.export(outfile, level, namespace_, name_='delimiter', pretty_print=pretty_print)
        for prefix_ in self.prefix:
            prefix_.export(outfile, level, namespace_, name_='prefix', pretty_print=pretty_print)
        for suffix_ in self.suffix:
            suffix_.export(outfile, level, namespace_, name_='suffix', pretty_print=pretty_print)
        if self.validTime is not None:
            self.validTime.export(outfile, level, namespace_, name_='validTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_EntityNameUse(self.use)    # validate type set_cs_EntityNameUse
        super(ON, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'delimiter':
            obj_ = en_delimiter.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'delimiter', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_delimiter'):
              self.add_delimiter(obj_.value)
            elif hasattr(self, 'set_delimiter'):
              self.set_delimiter(obj_.value)
        elif nodeName_ == 'prefix':
            obj_ = en_prefix.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'suffix':
            obj_ = en_suffix.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'suffix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_suffix'):
              self.add_suffix(obj_.value)
            elif hasattr(self, 'set_suffix'):
              self.set_suffix(obj_.value)
        elif nodeName_ == 'validTime':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class PN(EN):
    """A name for a person. A sequence of name parts, such as given name or
    family name, prefix, suffix, etc. PN differs from EN because the
    qualifier type cannot include LS (Legal Status)."""
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor=None, updateMode=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PN, self).__init__(nullFlavor, updateMode, use, delimiter, family, given, prefix, suffix, validTime, id, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN.subclass:
            return PN.subclass(*args_, **kwargs_)
        else:
            return PN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PN'):
        super(PN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PN')
    def exportChildren(self, outfile, level, namespace_='', name_='PN', fromsubclass_=False, pretty_print=True):
        super(PN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PN, self).buildChildren(child_, node, nodeName_, True)
        pass


class TN(EN):
    """A restriction of entity name that is effectively a simple string
    used for a simple name for things and places."""
    subclass = None
    superclass = EN
    def __init__(self, nullFlavor=None, updateMode=None, use=None, delimiter=None, family=None, given=None, prefix=None, suffix=None, validTime=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(TN, self).__init__(nullFlavor, updateMode, use, delimiter, family, given, prefix, suffix, validTime, id, valueOf_, mixedclass_, content_, )
        self.validTime = validTime
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TN.subclass:
            return TN.subclass(*args_, **kwargs_)
        else:
            return TN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_validTime(self): return self.validTime
    def set_validTime(self, validTime): self.validTime = validTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.validTime is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TN'):
        super(TN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TN')
    def exportChildren(self, outfile, level, namespace_='', name_='TN', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validTime is not None:
            self.validTime.export(outfile, level, namespace_, name_='validTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'validTime':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'validTime', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_validTime'):
              self.add_validTime(obj_.value)
            elif hasattr(self, 'set_validTime'):
              self.set_validTime(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class GLIST_PQ(ANY):
    """If non-NULL, specifies that the sequence alternates, i.e., after
    this many increments, the sequence item values roll over to
    start from the initial sequence item value. For example, the
    sequence (1; 2; 3; 1; 2; 3; 1; 2; 3; ...) has period 3; also the
    sequence (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period 3
    too. The integer by which the index for the sequence is divided,
    effectively the number of times the sequence generates the same
    sequence item value before incrementing to the next sequence
    item value. For example, to generate the sequence (1; 1; 1; 2;
    2; 2; 3; 3; 3; ...) the denominator is 3."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, period=None, denominator=None, head=None, increment=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(GLIST_PQ, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.period = _cast(None, period)
        self.denominator = _cast(None, denominator)
        self.head = head
        self.increment = increment
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_PQ.subclass:
            return GLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return GLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_head(self): return self.head
    def set_head(self, head): self.head = head
    def get_increment(self): return self.increment
    def set_increment(self, increment): self.increment = increment
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_denominator(self): return self.denominator
    def set_denominator(self, denominator): self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.head is not None or
            self.increment is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(GLIST_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GLIST_PQ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GLIST_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GLIST_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GLIST_PQ'):
        super(GLIST_PQ, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GLIST_PQ')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (quote_attrib(self.period), ))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator=%s' % (quote_attrib(self.denominator), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(GLIST_PQ, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            self.head.export(outfile, level, namespace_, name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            self.increment.export(outfile, level, namespace_, name_='increment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = value
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'head':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'head', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_head'):
              self.add_head(obj_.value)
            elif hasattr(self, 'set_head'):
              self.set_head(obj_.value)
        elif nodeName_ == 'increment':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'increment', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_increment'):
              self.add_increment(obj_.value)
            elif hasattr(self, 'set_increment'):
              self.set_increment(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(GLIST_PQ, self).buildChildren(child_, node, nodeName_, True)


class GLIST_TS(ANY):
    """If non-NULL, specifies that the sequence alternates, i.e., after
    this many increments, the sequence item values roll over to
    start from the initial sequence item value. For example, the
    sequence (1; 2; 3; 1; 2; 3; 1; 2; 3; ...) has period 3; also the
    sequence (1; 1; 2; 2; 3; 3; 1; 1; 2; 2; 3; 3; ...) has period 3
    too. The integer by which the index for the sequence is divided,
    effectively the number of times the sequence generates the same
    sequence item value before incrementing to the next sequence
    item value. For example, to generate the sequence (1; 1; 1; 2;
    2; 2; 3; 3; 3; ...) the denominator is 3."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, period=None, denominator=None, head=None, increment=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(GLIST_TS, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.period = _cast(None, period)
        self.denominator = _cast(None, denominator)
        self.head = head
        self.increment = increment
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GLIST_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GLIST_TS.subclass:
            return GLIST_TS.subclass(*args_, **kwargs_)
        else:
            return GLIST_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_head(self): return self.head
    def set_head(self, head): self.head = head
    def get_increment(self): return self.increment
    def set_increment(self, increment): self.increment = increment
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_denominator(self): return self.denominator
    def set_denominator(self, denominator): self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.head is not None or
            self.increment is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(GLIST_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GLIST_TS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GLIST_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GLIST_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GLIST_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GLIST_TS'):
        super(GLIST_TS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GLIST_TS')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (quote_attrib(self.period), ))
        if self.denominator is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            outfile.write(' denominator=%s' % (quote_attrib(self.denominator), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GLIST_TS', fromsubclass_=False, pretty_print=True):
        super(GLIST_TS, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            self.head.export(outfile, level, namespace_, name_='head', pretty_print=pretty_print)
        if self.increment is not None:
            self.increment.export(outfile, level, namespace_, name_='increment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
            self.validate_int(self.period)    # validate type int
        value = find_attr_value_('denominator', node)
        if value is not None and 'denominator' not in already_processed:
            already_processed.add('denominator')
            self.denominator = value
            self.validate_int(self.denominator)    # validate type int
        super(GLIST_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'head':
            class_obj_ = self.get_class_obj_(child_, TS)
            class_obj_ = TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'head', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_head'):
              self.add_head(obj_.value)
            elif hasattr(self, 'set_head'):
              self.set_head(obj_.value)
        elif nodeName_ == 'increment':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'increment', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_increment'):
              self.add_increment(obj_.value)
            elif hasattr(self, 'set_increment'):
              self.set_increment(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(GLIST_TS, self).buildChildren(child_, node, nodeName_, True)


class II(ANY):
    """An identifier that uniquely identifies a thing or object. Examples
    are object identifier for HL7 RIM objects, medical record
    number, order id, service catalog item id, Vehicle
    Identification Number (VIN), etc. Instance identifiers are
    defined based on ISO object identifiers. A unique identifier
    that guarantees the global uniqueness of the instance
    identifier. The root alone may be the entire instance
    identifier. A character string as a unique identifier within the
    scope of the identifier root. A human readable name or mnemonic
    for the assigning authority. This name may be provided solely
    for the convenience of unaided humans interpreting an II value
    and can have no computational meaning. Note: no automated
    processing must depend on the assigning authority name to be
    present in any form. Specifies if the identifier is intended for
    human display and data entry (displayable = true) as opposed to
    pure machine interoperation (displayable = false)."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(II, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.assigningAuthorityName = _cast(None, assigningAuthorityName)
        self.displayable = _cast(None, displayable)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II.subclass:
            return II.subclass(*args_, **kwargs_)
        else:
            return II(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_assigningAuthorityName(self): return self.assigningAuthorityName
    def set_assigningAuthorityName(self, assigningAuthorityName): self.assigningAuthorityName = assigningAuthorityName
    def get_displayable(self): return self.displayable
    def set_displayable(self, displayable): self.displayable = displayable
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(II, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II'):
        super(II, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.assigningAuthorityName is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            outfile.write(' assigningAuthorityName=%s' % (quote_attrib(self.assigningAuthorityName), ))
        if self.displayable is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            outfile.write(' displayable=%s' % (quote_attrib(self.displayable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II', fromsubclass_=False, pretty_print=True):
        super(II, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_uid(self.root)    # validate type uid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('assigningAuthorityName', node)
        if value is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            self.assigningAuthorityName = value
            self.validate_st(self.assigningAuthorityName)    # validate type st
        value = find_attr_value_('displayable', node)
        if value is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            self.displayable = value
            self.validate_bl(self.displayable)    # validate type bl
        super(II, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(II, self).buildChildren(child_, node, nodeName_, True)
        pass


class II_NPfIT_oid_required(II):
    subclass = None
    superclass = II
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NPfIT_oid_required, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.assigningAuthorityName = _cast(None, assigningAuthorityName)
        self.displayable = _cast(None, displayable)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NPfIT_oid_required)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NPfIT_oid_required.subclass:
            return II_NPfIT_oid_required.subclass(*args_, **kwargs_)
        else:
            return II_NPfIT_oid_required(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_assigningAuthorityName(self): return self.assigningAuthorityName
    def set_assigningAuthorityName(self, assigningAuthorityName): self.assigningAuthorityName = assigningAuthorityName
    def get_displayable(self): return self.displayable
    def set_displayable(self, displayable): self.displayable = displayable
    def validate_II_NPfIT_root_oid(self, value):
        # Validate type II.NPfIT.root.oid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_oid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_oid_patterns_, ))
    validate_II_NPfIT_root_oid_patterns_ = [['^([0-9][0-9]*)(\\.[0-9][0-9]*)*$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            super(II_NPfIT_oid_required, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NPfIT.oid.required', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NPfIT.oid.required')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.oid.required')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NPfIT.oid.required', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NPfIT.oid.required'):
        super(II_NPfIT_oid_required, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.oid.required')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.assigningAuthorityName is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            outfile.write(' assigningAuthorityName=%s' % (quote_attrib(self.assigningAuthorityName), ))
        if self.displayable is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            outfile.write(' displayable=%s' % (quote_attrib(self.displayable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NPfIT.oid.required', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_oid(self.root)    # validate type II.NPfIT.root.oid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('assigningAuthorityName', node)
        if value is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            self.assigningAuthorityName = value
            self.validate_st(self.assigningAuthorityName)    # validate type st
        value = find_attr_value_('displayable', node)
        if value is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            self.displayable = value
            self.validate_bl(self.displayable)    # validate type bl
        super(II_NPfIT_oid_required, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class II_NHS_IdentifierType1(II_NPfIT_oid_required):
    subclass = None
    superclass = II_NPfIT_oid_required
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NHS_IdentifierType1, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NHS_IdentifierType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NHS_IdentifierType1.subclass:
            return II_NHS_IdentifierType1.subclass(*args_, **kwargs_)
        else:
            return II_NHS_IdentifierType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def validate_II_NPfIT_root_oid(self, value):
        # Validate type II.NPfIT.root.oid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_oid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_oid_patterns_, ))
    validate_II_NPfIT_root_oid_patterns_ = [['^([0-9][0-9]*)(\\.[0-9][0-9]*)*$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            super(II_NHS_IdentifierType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NHS.IdentifierType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NHS.IdentifierType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NHS.IdentifierType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NHS.IdentifierType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NHS.IdentifierType1'):
        super(II_NHS_IdentifierType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NHS.IdentifierType1')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NHS.IdentifierType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_oid(self.root)    # validate type II.NPfIT.root.oid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        super(II_NHS_IdentifierType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class II_NHS_IdentifierType3(II_NPfIT_oid_required):
    subclass = None
    superclass = II_NPfIT_oid_required
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NHS_IdentifierType3, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NHS_IdentifierType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NHS_IdentifierType3.subclass:
            return II_NHS_IdentifierType3.subclass(*args_, **kwargs_)
        else:
            return II_NHS_IdentifierType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def validate_II_NPfIT_root_oid(self, value):
        # Validate type II.NPfIT.root.oid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_oid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_oid_patterns_, ))
    validate_II_NPfIT_root_oid_patterns_ = [['^([0-9][0-9]*)(\\.[0-9][0-9]*)*$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            super(II_NHS_IdentifierType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NHS.IdentifierType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NHS.IdentifierType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NHS.IdentifierType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NHS.IdentifierType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NHS.IdentifierType3'):
        super(II_NHS_IdentifierType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NHS.IdentifierType3')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NHS.IdentifierType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_oid(self.root)    # validate type II.NPfIT.root.oid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        super(II_NHS_IdentifierType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class II_NPfIT_oid_mandatory(II_NPfIT_oid_required):
    subclass = None
    superclass = II_NPfIT_oid_required
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NPfIT_oid_mandatory, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NPfIT_oid_mandatory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NPfIT_oid_mandatory.subclass:
            return II_NPfIT_oid_mandatory.subclass(*args_, **kwargs_)
        else:
            return II_NPfIT_oid_mandatory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def validate_II_NPfIT_root_oid(self, value):
        # Validate type II.NPfIT.root.oid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_oid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_oid_patterns_, ))
    validate_II_NPfIT_root_oid_patterns_ = [['^([0-9][0-9]*)(\\.[0-9][0-9]*)*$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            super(II_NPfIT_oid_mandatory, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NPfIT.oid.mandatory', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NPfIT.oid.mandatory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.oid.mandatory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NPfIT.oid.mandatory', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NPfIT.oid.mandatory'):
        super(II_NPfIT_oid_mandatory, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.oid.mandatory')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NPfIT.oid.mandatory', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_oid(self.root)    # validate type II.NPfIT.root.oid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        super(II_NPfIT_oid_mandatory, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class II_NPfIT_uuid_required(II):
    subclass = None
    superclass = II
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NPfIT_uuid_required, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.assigningAuthorityName = _cast(None, assigningAuthorityName)
        self.displayable = _cast(None, displayable)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NPfIT_uuid_required)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NPfIT_uuid_required.subclass:
            return II_NPfIT_uuid_required.subclass(*args_, **kwargs_)
        else:
            return II_NPfIT_uuid_required(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_assigningAuthorityName(self): return self.assigningAuthorityName
    def set_assigningAuthorityName(self, assigningAuthorityName): self.assigningAuthorityName = assigningAuthorityName
    def get_displayable(self): return self.displayable
    def set_displayable(self, displayable): self.displayable = displayable
    def validate_II_NPfIT_root_uuid(self, value):
        # Validate type II.NPfIT.root.uuid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_uuid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_uuid_patterns_, ))
    validate_II_NPfIT_root_uuid_patterns_ = [['^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            super(II_NPfIT_uuid_required, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NPfIT.uuid.required', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NPfIT.uuid.required')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.uuid.required')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NPfIT.uuid.required', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NPfIT.uuid.required'):
        super(II_NPfIT_uuid_required, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.uuid.required')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.assigningAuthorityName is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            outfile.write(' assigningAuthorityName=%s' % (quote_attrib(self.assigningAuthorityName), ))
        if self.displayable is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            outfile.write(' displayable=%s' % (quote_attrib(self.displayable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NPfIT.uuid.required', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_uuid(self.root)    # validate type II.NPfIT.root.uuid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('assigningAuthorityName', node)
        if value is not None and 'assigningAuthorityName' not in already_processed:
            already_processed.add('assigningAuthorityName')
            self.assigningAuthorityName = value
            self.validate_st(self.assigningAuthorityName)    # validate type st
        value = find_attr_value_('displayable', node)
        if value is not None and 'displayable' not in already_processed:
            already_processed.add('displayable')
            self.displayable = value
            self.validate_bl(self.displayable)    # validate type bl
        super(II_NPfIT_uuid_required, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class II_NHS_IdentifierType2(II_NPfIT_uuid_required):
    subclass = None
    superclass = II_NPfIT_uuid_required
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NHS_IdentifierType2, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NHS_IdentifierType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NHS_IdentifierType2.subclass:
            return II_NHS_IdentifierType2.subclass(*args_, **kwargs_)
        else:
            return II_NHS_IdentifierType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def validate_II_NPfIT_root_uuid(self, value):
        # Validate type II.NPfIT.root.uuid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_uuid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_uuid_patterns_, ))
    validate_II_NPfIT_root_uuid_patterns_ = [['^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            super(II_NHS_IdentifierType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NHS.IdentifierType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NHS.IdentifierType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NHS.IdentifierType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NHS.IdentifierType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NHS.IdentifierType2'):
        super(II_NHS_IdentifierType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NHS.IdentifierType2')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NHS.IdentifierType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_uuid(self.root)    # validate type II.NPfIT.root.uuid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        super(II_NHS_IdentifierType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class II_NPfIT_uuid_mandatory(II_NPfIT_uuid_required):
    subclass = None
    superclass = II_NPfIT_uuid_required
    def __init__(self, nullFlavor=None, updateMode=None, root=None, extension=None, assigningAuthorityName=None, displayable=None):
        self.original_tagname_ = None
        super(II_NPfIT_uuid_mandatory, self).__init__(nullFlavor, updateMode, root, extension, assigningAuthorityName, displayable, )
        self.root = _cast(None, root)
        self.extension = _cast(None, extension)
        self.nullFlavor = _cast(None, nullFlavor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, II_NPfIT_uuid_mandatory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if II_NPfIT_uuid_mandatory.subclass:
            return II_NPfIT_uuid_mandatory.subclass(*args_, **kwargs_)
        else:
            return II_NPfIT_uuid_mandatory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def validate_II_NPfIT_root_uuid(self, value):
        # Validate type II.NPfIT.root.uuid, a restriction on uid.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_II_NPfIT_root_uuid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_II_NPfIT_root_uuid_patterns_, ))
    validate_II_NPfIT_root_uuid_patterns_ = [['^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$']]
    def validate_st(self, value):
        # Validate type st, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on st' % {"value" : value.encode("utf-8")} )
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            super(II_NPfIT_uuid_mandatory, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='II.NPfIT.uuid.mandatory', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('II.NPfIT.uuid.mandatory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.uuid.mandatory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='II.NPfIT.uuid.mandatory', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='II.NPfIT.uuid.mandatory'):
        super(II_NPfIT_uuid_mandatory, self).exportAttributes(outfile, level, already_processed, namespace_, name_='II.NPfIT.uuid.mandatory')
        if self.root is not None and 'root' not in already_processed:
            already_processed.add('root')
            outfile.write(' root=%s' % (quote_attrib(self.root), ))
        if self.extension is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            outfile.write(' extension=%s' % (quote_attrib(self.extension), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
    def exportChildren(self, outfile, level, namespace_='', name_='II.NPfIT.uuid.mandatory', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('root', node)
        if value is not None and 'root' not in already_processed:
            already_processed.add('root')
            self.root = value
            self.validate_II_NPfIT_root_uuid(self.root)    # validate type II.NPfIT.root.uuid
        value = find_attr_value_('extension', node)
        if value is not None and 'extension' not in already_processed:
            already_processed.add('extension')
            self.extension = value
            self.validate_st(self.extension)    # validate type st
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        super(II_NPfIT_uuid_mandatory, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class IVL_INT(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, low=None, high=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(IVL_INT, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.value = _cast(None, value)
        self.low = low
        self.high = high
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_INT.subclass:
            return IVL_INT.subclass(*args_, **kwargs_)
        else:
            return IVL_INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self): return self.low
    def set_low(self, low): self.low = low
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_int(self, value):
        # Validate type int, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IVL_INT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IVL_INT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IVL_INT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IVL_INT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IVL_INT'):
        super(IVL_INT, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IVL_INT')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IVL_INT', fromsubclass_=False, pretty_print=True):
        super(IVL_INT, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            self.low.export(outfile, level, namespace_, name_='low', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_int(self.value)    # validate type int
        super(IVL_INT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'low':
            obj_ = lowType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = highType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_INT, self).buildChildren(child_, node, nodeName_, True)


class IVL_PQ(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, operator='I', low=None, high=None, width=None, center=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(IVL_PQ, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.operator = _cast(None, operator)
        self.low = low
        self.high = high
        self.width = width
        self.high = high
        self.center = center
        self.width = width
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_PQ.subclass:
            return IVL_PQ.subclass(*args_, **kwargs_)
        else:
            return IVL_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self): return self.low
    def set_low(self, low): self.low = low
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def get_center(self): return self.center
    def set_center(self, center): self.center = center
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_SetOperator(self, value):
        # Validate type cs_SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['I', 'E', 'A', 'H', 'P']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_SetOperator' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_SetOperator_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_SetOperator_patterns_, ))
    validate_cs_SetOperator_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IVL_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IVL_PQ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IVL_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IVL_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IVL_PQ'):
        super(IVL_PQ, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IVL_PQ')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IVL_PQ', fromsubclass_=False, pretty_print=True):
        super(IVL_PQ, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            self.low.export(outfile, level, namespace_, name_='low', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
        if self.center is not None:
            self.center.export(outfile, level, namespace_, name_='center', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_cs_SetOperator(self.operator)    # validate type cs_SetOperator
        super(IVL_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'low':
            obj_ = PQ_inc.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = PQ_inc.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = PQ_inc.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_PQ, self).buildChildren(child_, node, nodeName_, True)


class PN_NHS_Internal(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, use=None, prefix=None, given=None, family=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PN_NHS_Internal, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        self.prefix = prefix
        if given is None:
            self.given = []
        else:
            self.given = given
        self.family = family
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN_NHS_Internal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN_NHS_Internal.subclass:
            return PN_NHS_Internal.subclass(*args_, **kwargs_)
        else:
            return PN_NHS_Internal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_given(self): return self.given
    def set_given(self, given): self.given = given
    def add_given(self, value): self.given.append(value)
    def insert_given_at(self, index, value): self.given.insert(index, value)
    def replace_given_at(self, index, value): self.given[index] = value
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_EntityNameUse(self, value):
        # Validate type set_cs_EntityNameUse, a restriction on cs_EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.prefix is not None or
            self.given or
            self.family is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PN_NHS_Internal, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PN.NHS.Internal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN.NHS.Internal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.Internal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PN.NHS.Internal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PN.NHS.Internal'):
        super(PN_NHS_Internal, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.Internal')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PN.NHS.Internal', fromsubclass_=False, pretty_print=True):
        super(PN_NHS_Internal, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prefix is not None:
            self.prefix.export(outfile, level, namespace_, name_='prefix', pretty_print=pretty_print)
        for given_ in self.given:
            given_.export(outfile, level, namespace_, name_='given', pretty_print=pretty_print)
        if self.family is not None:
            self.family.export(outfile, level, namespace_, name_='family', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_EntityNameUse(self.use)    # validate type set_cs_EntityNameUse
        super(PN_NHS_Internal, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prefix':
            obj_ = en_prefix.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'given':
            obj_ = en_given.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PN_NHS_Internal, self).buildChildren(child_, node, nodeName_, True)


class PN_NHS_PersonNameType1(PN_NHS_Internal):
    subclass = None
    superclass = PN_NHS_Internal
    def __init__(self, nullFlavor=None, updateMode=None, use=None, prefix=None, given=None, family=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PN_NHS_PersonNameType1, self).__init__(nullFlavor, updateMode, use, prefix, given, family, valueOf_, mixedclass_, content_, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.use = _cast(None, use)
        self.given = given
        self.family = family
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN_NHS_PersonNameType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN_NHS_PersonNameType1.subclass:
            return PN_NHS_PersonNameType1.subclass(*args_, **kwargs_)
        else:
            return PN_NHS_PersonNameType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_given(self): return self.given
    def set_given(self, given): self.given = given
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_set_cs_EntityNameUse(self, value):
        # Validate type set_cs_EntityNameUse, a restriction on cs_EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.given is not None or
            self.family is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PN_NHS_PersonNameType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PN.NHS.PersonNameType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN.NHS.PersonNameType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.PersonNameType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PN.NHS.PersonNameType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PN.NHS.PersonNameType1'):
        super(PN_NHS_PersonNameType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.PersonNameType1')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PN.NHS.PersonNameType1', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.given is not None:
            self.given.export(outfile, level, namespace_, name_='given', pretty_print=pretty_print)
        if self.family is not None:
            self.family.export(outfile, level, namespace_, name_='family', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_EntityNameUse(self.use)    # validate type set_cs_EntityNameUse
        super(PN_NHS_PersonNameType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'given':
            obj_ = en_given.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class PN_NHS_PersonNameType2(PN_NHS_Internal):
    subclass = None
    superclass = PN_NHS_Internal
    def __init__(self, nullFlavor=None, updateMode=None, use=None, prefix=None, given=None, family=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PN_NHS_PersonNameType2, self).__init__(nullFlavor, updateMode, use, prefix, given, family, valueOf_, mixedclass_, content_, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.use = _cast(None, use)
        self.prefix = prefix
        if given is None:
            self.given = []
        else:
            self.given = given
        self.family = family
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN_NHS_PersonNameType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN_NHS_PersonNameType2.subclass:
            return PN_NHS_PersonNameType2.subclass(*args_, **kwargs_)
        else:
            return PN_NHS_PersonNameType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_given(self): return self.given
    def set_given(self, given): self.given = given
    def add_given(self, value): self.given.append(value)
    def insert_given_at(self, index, value): self.given.insert(index, value)
    def replace_given_at(self, index, value): self.given[index] = value
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_set_cs_EntityNameUse(self, value):
        # Validate type set_cs_EntityNameUse, a restriction on cs_EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.prefix is not None or
            self.given or
            self.family is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PN_NHS_PersonNameType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PN.NHS.PersonNameType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN.NHS.PersonNameType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.PersonNameType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PN.NHS.PersonNameType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PN.NHS.PersonNameType2'):
        super(PN_NHS_PersonNameType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.PersonNameType2')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PN.NHS.PersonNameType2', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prefix is not None:
            self.prefix.export(outfile, level, namespace_, name_='prefix', pretty_print=pretty_print)
        for given_ in self.given:
            given_.export(outfile, level, namespace_, name_='given', pretty_print=pretty_print)
        if self.family is not None:
            self.family.export(outfile, level, namespace_, name_='family', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_EntityNameUse(self.use)    # validate type set_cs_EntityNameUse
        super(PN_NHS_PersonNameType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prefix':
            obj_ = en_prefix.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'prefix', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_prefix'):
              self.add_prefix(obj_.value)
            elif hasattr(self, 'set_prefix'):
              self.set_prefix(obj_.value)
        elif nodeName_ == 'given':
            obj_ = en_given.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class PN_NHS_PersonNameType3(PN_NHS_Internal):
    subclass = None
    superclass = PN_NHS_Internal
    def __init__(self, nullFlavor=None, updateMode=None, use=None, prefix=None, given=None, family=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PN_NHS_PersonNameType3, self).__init__(nullFlavor, updateMode, use, prefix, given, family, valueOf_, mixedclass_, content_, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.use = _cast(None, use)
        self.given = given
        self.family = family
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PN_NHS_PersonNameType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PN_NHS_PersonNameType3.subclass:
            return PN_NHS_PersonNameType3.subclass(*args_, **kwargs_)
        else:
            return PN_NHS_PersonNameType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_given(self): return self.given
    def set_given(self, given): self.given = given
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_set_cs_EntityNameUse(self, value):
        # Validate type set_cs_EntityNameUse, a restriction on cs_EntityNameUse.
        pass
    def hasContent_(self):
        if (
            self.given is not None or
            self.family is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PN_NHS_PersonNameType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PN.NHS.PersonNameType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PN.NHS.PersonNameType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.PersonNameType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PN.NHS.PersonNameType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PN.NHS.PersonNameType3'):
        super(PN_NHS_PersonNameType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PN.NHS.PersonNameType3')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PN.NHS.PersonNameType3', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.given is not None:
            self.given.export(outfile, level, namespace_, name_='given', pretty_print=pretty_print)
        if self.family is not None:
            self.family.export(outfile, level, namespace_, name_='family', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_EntityNameUse(self.use)    # validate type set_cs_EntityNameUse
        super(PN_NHS_PersonNameType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'given':
            obj_ = en_given.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'given', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_given'):
              self.add_given(obj_.value)
            elif hasattr(self, 'set_given'):
              self.set_given(obj_.value)
        elif nodeName_ == 'family':
            obj_ = en_family.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'family', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_family'):
              self.add_family(obj_.value)
            elif hasattr(self, 'set_family'):
              self.set_family(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class QTY(ANY):
    """The quantity data type is an abstract generalization for all data
    types (1) whose value set has an order relation (less-or-equal)
    and (2) where difference is defined in all of the data type's
    totally ordered value subsets. The quantity type abstraction is
    needed in defining certain other types, such as the interval and
    the probability distribution."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(QTY, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QTY.subclass:
            return QTY.subclass(*args_, **kwargs_)
        else:
            return QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(QTY, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QTY', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QTY')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QTY'):
        super(QTY, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='QTY', fromsubclass_=False, pretty_print=True):
        super(QTY, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QTY, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(QTY, self).buildChildren(child_, node, nodeName_, True)
        pass


class INT(QTY):
    """Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
    that are results of counting and enumerating. Integer numbers
    are discrete, the set of integers is infinite but countable. No
    arbitrary limit is imposed on the range of integer numbers. Two
    NULL flavors are defined for the positive and negative infinity."""
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(INT, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT.subclass:
            return INT.subclass(*args_, **kwargs_)
        else:
            return INT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_int(self, value):
        # Validate type int, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(INT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INT')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INT'):
        super(INT, self).exportAttributes(outfile, level, already_processed, namespace_, name_='INT')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='INT', fromsubclass_=False, pretty_print=True):
        super(INT, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_int(self.value)    # validate type int
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(INT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(INT, self).buildChildren(child_, node, nodeName_, True)
        pass


class highType(INT):
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor=None, updateMode=None, value=None, inclusive='true', valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(highType, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, )
        self.inclusive = _cast(None, inclusive)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, highType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if highType.subclass:
            return highType.subclass(*args_, **kwargs_)
        else:
            return highType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inclusive(self): return self.inclusive
    def set_inclusive(self, inclusive): self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(highType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='highType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('highType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='highType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='highType'):
        super(highType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='highType')
        if self.inclusive != "true" and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive=%s' % (quote_attrib(self.inclusive), ))
    def exportChildren(self, outfile, level, namespace_='', name_='highType', fromsubclass_=False, pretty_print=True):
        super(highType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            self.inclusive = value
            self.validate_bl(self.inclusive)    # validate type bl
        super(highType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(highType, self).buildChildren(child_, node, nodeName_, True)
        pass


class lowType(INT):
    subclass = None
    superclass = INT
    def __init__(self, nullFlavor=None, updateMode=None, value=None, inclusive='true', valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(lowType, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, )
        self.inclusive = _cast(None, inclusive)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lowType.subclass:
            return lowType.subclass(*args_, **kwargs_)
        else:
            return lowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inclusive(self): return self.inclusive
    def set_inclusive(self, inclusive): self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(lowType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lowType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lowType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lowType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lowType'):
        super(lowType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='lowType')
        if self.inclusive != "true" and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive=%s' % (quote_attrib(self.inclusive), ))
    def exportChildren(self, outfile, level, namespace_='', name_='lowType', fromsubclass_=False, pretty_print=True):
        super(lowType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            self.inclusive = value
            self.validate_bl(self.inclusive)    # validate type bl
        super(lowType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(lowType, self).buildChildren(child_, node, nodeName_, True)
        pass


class MO(QTY):
    """A monetary amount is a quantity expressing the amount of money in
    some currency. Currencies are the units in which monetary
    amounts are denominated in different economic regions. While the
    monetary amount is a single kind of quantity (money) the
    exchange rates between the different units are variable. This is
    the principle difference between physical quantity and monetary
    amounts, and the reason why currency units are not physical
    units. The magnitude of the monetary amount in terms of the
    currency unit. The currency unit as defined in ISO 4217."""
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, currency=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(MO, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.value = _cast(None, value)
        self.currency = _cast(None, currency)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MO.subclass:
            return MO.subclass(*args_, **kwargs_)
        else:
            return MO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(MO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MO', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MO')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MO'):
        super(MO, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MO')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (quote_attrib(self.currency), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MO', fromsubclass_=False, pretty_print=True):
        super(MO, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
            self.validate_cs(self.currency)    # validate type cs
        super(MO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(MO, self).buildChildren(child_, node, nodeName_, True)
        pass


class PQ(QTY):
    """A dimensioned quantity expressing the result of a measurement act.
    The magnitude of the quantity measured in terms of the unit. The
    unit of measure specified in the Unified Code for Units of
    Measure (UCUM) [http://aurora.rg.iupui.edu/UCUM]."""
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, unit='1', translation=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PQ, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQ.subclass:
            return PQ.subclass(*args_, **kwargs_)
        else:
            return PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def add_translation(self, value): self.translation.append(value)
    def insert_translation_at(self, index, value): self.translation.insert(index, value)
    def replace_translation_at(self, index, value): self.translation[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.translation or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PQ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PQ'):
        super(PQ, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PQ')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit != "1" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PQ', fromsubclass_=False, pretty_print=True):
        super(PQ, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for translation_ in self.translation:
            translation_.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_cs(self.unit)    # validate type cs
        super(PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'translation':
            obj_ = PQR.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'translation', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_translation'):
              self.add_translation(obj_.value)
            elif hasattr(self, 'set_translation'):
              self.set_translation(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PQ, self).buildChildren(child_, node, nodeName_, True)


class REAL(QTY):
    """Fractional numbers. Typically used whenever quantities are measured,
    estimated, or computed from other real numbers. The typical
    representation is decimal, where the number of significant
    decimal digits is known as the precision. Real numbers are
    needed beyond integers whenever quantities of the real world are
    measured, estimated, or computed from other real numbers. The
    term "Real number" in this specification is used to mean that
    fractional values are covered without necessarily implying the
    full set of the mathematical real numbers."""
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(REAL, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL.subclass:
            return REAL.subclass(*args_, **kwargs_)
        else:
            return REAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(REAL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='REAL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='REAL')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='REAL'):
        super(REAL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='REAL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='REAL', fromsubclass_=False, pretty_print=True):
        super(REAL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        super(REAL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(REAL, self).buildChildren(child_, node, nodeName_, True)
        pass


class RTO_QTY_QTY(QTY):
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, numerator=None, denominator=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(RTO_QTY_QTY, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.numerator = numerator
        self.denominator = denominator
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO_QTY_QTY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO_QTY_QTY.subclass:
            return RTO_QTY_QTY.subclass(*args_, **kwargs_)
        else:
            return RTO_QTY_QTY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numerator(self): return self.numerator
    def set_numerator(self, numerator): self.numerator = numerator
    def get_denominator(self): return self.denominator
    def set_denominator(self, denominator): self.denominator = denominator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.numerator is not None or
            self.denominator is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(RTO_QTY_QTY, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RTO_QTY_QTY', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO_QTY_QTY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RTO_QTY_QTY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RTO_QTY_QTY', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RTO_QTY_QTY'):
        super(RTO_QTY_QTY, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RTO_QTY_QTY')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RTO_QTY_QTY', fromsubclass_=False, pretty_print=True):
        super(RTO_QTY_QTY, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numerator is not None:
            self.numerator.export(outfile, level, namespace_, name_='numerator', pretty_print=pretty_print)
        if self.denominator is not None:
            self.denominator.export(outfile, level, namespace_, name_='denominator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RTO_QTY_QTY, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numerator':
            obj_ = numeratorType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'numerator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_numerator'):
              self.add_numerator(obj_.value)
            elif hasattr(self, 'set_numerator'):
              self.set_numerator(obj_.value)
        elif nodeName_ == 'denominator':
            obj_ = denominatorType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'denominator', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_denominator'):
              self.add_denominator(obj_.value)
            elif hasattr(self, 'set_denominator'):
              self.set_denominator(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO_QTY_QTY, self).buildChildren(child_, node, nodeName_, True)


class RTO(RTO_QTY_QTY):
    """A quantity constructed as the quotient of a numerator quantity
    divided by a denominator quantity. Common factors in the
    numerator and denominator are not automatically cancelled out.
    The data type supports titers (e.g., "1:128") and other
    quantities produced by laboratories that truly represent ratios.
    Ratios are not simply "structured numerics", particularly blood
    pressure measurements (e.g. "120/60") are not ratios. In many
    cases the REAL should be used instead of the ."""
    subclass = None
    superclass = RTO_QTY_QTY
    def __init__(self, nullFlavor=None, updateMode=None, numerator=None, denominator=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(RTO, self).__init__(nullFlavor, updateMode, numerator, denominator, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTO.subclass:
            return RTO.subclass(*args_, **kwargs_)
        else:
            return RTO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(RTO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RTO', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RTO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RTO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RTO'):
        super(RTO, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RTO')
    def exportChildren(self, outfile, level, namespace_='', name_='RTO', fromsubclass_=False, pretty_print=True):
        super(RTO, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RTO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(RTO, self).buildChildren(child_, node, nodeName_, True)
        pass


class TS(QTY):
    """A quantity specifying a point on the axis of natural time. A point
    in time is most often represented as a calendar expression."""
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(TS, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS.subclass:
            return TS.subclass(*args_, **kwargs_)
        else:
            return TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ts(self, value):
        # Validate type ts, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^[0-9]{1,8}$|^([0-9]{9,14}$|^[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TS')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TS'):
        super(TS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TS')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='TS', fromsubclass_=False, pretty_print=True):
        super(TS, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TS, self).buildChildren(child_, node, nodeName_, True)
        pass


class IVXB_TS(TS):
    """Specifies whether the limit is included in the interval (interval is
    closed) or excluded from the interval (interval is open)."""
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None, inclusive='true', valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(IVXB_TS, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, )
        self.inclusive = _cast(None, inclusive)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVXB_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVXB_TS.subclass:
            return IVXB_TS.subclass(*args_, **kwargs_)
        else:
            return IVXB_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inclusive(self): return self.inclusive
    def set_inclusive(self, inclusive): self.inclusive = inclusive
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IVXB_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IVXB_TS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVXB_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IVXB_TS')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IVXB_TS'):
        super(IVXB_TS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IVXB_TS')
        if self.inclusive != "true" and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive=%s' % (quote_attrib(self.inclusive), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IVXB_TS', fromsubclass_=False, pretty_print=True):
        super(IVXB_TS, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            self.inclusive = value
            self.validate_bl(self.inclusive)    # validate type bl
        super(IVXB_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVXB_TS, self).buildChildren(child_, node, nodeName_, True)
        pass


class SXCM_TS(TS):
    """A code specifying whether the set component is included (union) or
    excluded (set-difference) from the set, or other set operations
    with the current set component and the set as constructed from
    the representation stream up to the current point."""
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None, operator='I', valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(SXCM_TS, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, extensiontype_, )
        self.operator = _cast(None, operator)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SXCM_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SXCM_TS.subclass:
            return SXCM_TS.subclass(*args_, **kwargs_)
        else:
            return SXCM_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cs_SetOperator(self, value):
        # Validate type cs_SetOperator, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['I', 'E', 'A', 'H', 'P']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_SetOperator' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_SetOperator_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_SetOperator_patterns_, ))
    validate_cs_SetOperator_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SXCM_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SXCM_TS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SXCM_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SXCM_TS')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SXCM_TS'):
        super(SXCM_TS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SXCM_TS')
        if self.operator != "I" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='SXCM_TS', fromsubclass_=False, pretty_print=True):
        super(SXCM_TS, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_cs_SetOperator(self.operator)    # validate type cs_SetOperator
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SXCM_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SXCM_TS, self).buildChildren(child_, node, nodeName_, True)
        pass


class IVL_TS(SXCM_TS):
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None, operator='I', low=None, high=None, width=None, center=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(IVL_TS, self).__init__(nullFlavor, updateMode, value, operator, valueOf_, mixedclass_, content_, )
        self.low = low
        self.high = high
        self.width = width
        self.high = high
        self.center = center
        self.width = width
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IVL_TS.subclass:
            return IVL_TS.subclass(*args_, **kwargs_)
        else:
            return IVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self): return self.low
    def set_low(self, low): self.low = low
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def get_center(self): return self.center
    def set_center(self, center): self.center = center
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None or
            self.width is not None or
            self.high is not None or
            self.center is not None or
            self.width is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IVL_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IVL_TS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IVL_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IVL_TS'):
        super(IVL_TS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IVL_TS')
    def exportChildren(self, outfile, level, namespace_='', name_='IVL_TS', fromsubclass_=False, pretty_print=True):
        super(IVL_TS, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            self.low.export(outfile, level, namespace_, name_='low', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
        if self.center is not None:
            self.center.export(outfile, level, namespace_, name_='center', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IVL_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'low':
            obj_ = IVXB_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'low', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_low'):
              self.add_low(obj_.value)
            elif hasattr(self, 'set_low'):
              self.set_low(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'width':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        elif nodeName_ == 'high':
            obj_ = IVXB_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'high', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_high'):
              self.add_high(obj_.value)
            elif hasattr(self, 'set_high'):
              self.set_high(obj_.value)
        elif nodeName_ == 'center':
            class_obj_ = self.get_class_obj_(child_, TS)
            class_obj_ = TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
              self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
              self.set_center(obj_.value)
        elif nodeName_ == 'width':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'width', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_width'):
              self.add_width(obj_.value)
            elif hasattr(self, 'set_width'):
              self.set_width(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IVL_TS, self).buildChildren(child_, node, nodeName_, True)


class PIVL_TS(SXCM_TS):
    """Note: because this type is defined as an extension of SXCM_T, all of
    the attributes and elements accepted for T are also accepted by
    this definition. However, they are NOT allowed by the normative
    description of this type. Unfortunately, we cannot write a
    general purpose schematron contraints to provide that extra
    validation, thus applications must be aware that instance
    (fragments) that pass validation with this might might still not
    be legal. Specifies if and how the repetitions are aligned to
    the cycles of the underlying calendar (e.g., to distinguish
    every 30 days from "the 5th of every month".) A non-aligned
    periodic interval recurs independently from the calendar. An
    aligned periodic interval is synchronized with the calendar.
    Indicates whether the exact timing is up to the party executing
    the schedule (e.g., to distinguish "every 8 hours" from "3 times
    a day".)"""
    subclass = None
    superclass = SXCM_TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None, operator='I', alignment=None, institutionSpecified='false', phase=None, period=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(PIVL_TS, self).__init__(nullFlavor, updateMode, value, operator, valueOf_, mixedclass_, content_, )
        self.alignment = _cast(None, alignment)
        self.institutionSpecified = _cast(None, institutionSpecified)
        self.phase = phase
        self.period = period
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIVL_TS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIVL_TS.subclass:
            return PIVL_TS.subclass(*args_, **kwargs_)
        else:
            return PIVL_TS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_alignment(self): return self.alignment
    def set_alignment(self, alignment): self.alignment = alignment
    def get_institutionSpecified(self): return self.institutionSpecified
    def set_institutionSpecified(self, institutionSpecified): self.institutionSpecified = institutionSpecified
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_CalendarCycle(self, value):
        # Validate type CalendarCycle, a restriction on None.
        pass
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def hasContent_(self):
        if (
            self.phase is not None or
            self.period is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PIVL_TS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PIVL_TS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIVL_TS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PIVL_TS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PIVL_TS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PIVL_TS'):
        super(PIVL_TS, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PIVL_TS')
        if self.alignment is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            outfile.write(' alignment=%s' % (quote_attrib(self.alignment), ))
        if self.institutionSpecified != "false" and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            outfile.write(' institutionSpecified=%s' % (quote_attrib(self.institutionSpecified), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PIVL_TS', fromsubclass_=False, pretty_print=True):
        super(PIVL_TS, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.phase is not None:
            self.phase.export(outfile, level, namespace_, name_='phase', pretty_print=pretty_print)
        if self.period is not None:
            self.period.export(outfile, level, namespace_, name_='period', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alignment', node)
        if value is not None and 'alignment' not in already_processed:
            already_processed.add('alignment')
            self.alignment = value
            self.validate_CalendarCycle(self.alignment)    # validate type CalendarCycle
        value = find_attr_value_('institutionSpecified', node)
        if value is not None and 'institutionSpecified' not in already_processed:
            already_processed.add('institutionSpecified')
            self.institutionSpecified = value
            self.validate_bl(self.institutionSpecified)    # validate type bl
        super(PIVL_TS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'phase':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'phase', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_phase'):
              self.add_phase(obj_.value)
            elif hasattr(self, 'set_phase'):
              self.set_phase(obj_.value)
        elif nodeName_ == 'period':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'period', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_period'):
              self.add_period(obj_.value)
            elif hasattr(self, 'set_period'):
              self.set_period(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(PIVL_TS, self).buildChildren(child_, node, nodeName_, True)


class TS_NHS_TimestampType1(TS):
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None):
        self.original_tagname_ = None
        super(TS_NHS_TimestampType1, self).__init__(nullFlavor, updateMode, value, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS_NHS_TimestampType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS_NHS_TimestampType1.subclass:
            return TS_NHS_TimestampType1.subclass(*args_, **kwargs_)
        else:
            return TS_NHS_TimestampType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_ts(self, value):
        # Validate type ts, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^[0-9]{1,8}$|^([0-9]{9,14}$|^[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            super(TS_NHS_TimestampType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS.NHS.TimestampType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TS.NHS.TimestampType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TS.NHS.TimestampType1'):
        super(TS_NHS_TimestampType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType1')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        super(TS_NHS_TimestampType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class TS_NHS_TimestampType2(TS):
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None):
        self.original_tagname_ = None
        super(TS_NHS_TimestampType2, self).__init__(nullFlavor, updateMode, value, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS_NHS_TimestampType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS_NHS_TimestampType2.subclass:
            return TS_NHS_TimestampType2.subclass(*args_, **kwargs_)
        else:
            return TS_NHS_TimestampType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_ts(self, value):
        # Validate type ts, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^[0-9]{1,8}$|^([0-9]{9,14}$|^[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            super(TS_NHS_TimestampType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS.NHS.TimestampType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TS.NHS.TimestampType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TS.NHS.TimestampType2'):
        super(TS_NHS_TimestampType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType2')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        super(TS_NHS_TimestampType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class TS_NHS_TimestampType3(TS):
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None):
        self.original_tagname_ = None
        super(TS_NHS_TimestampType3, self).__init__(nullFlavor, updateMode, value, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS_NHS_TimestampType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS_NHS_TimestampType3.subclass:
            return TS_NHS_TimestampType3.subclass(*args_, **kwargs_)
        else:
            return TS_NHS_TimestampType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_ts(self, value):
        # Validate type ts, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^[0-9]{1,8}$|^([0-9]{9,14}$|^[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            super(TS_NHS_TimestampType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS.NHS.TimestampType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TS.NHS.TimestampType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TS.NHS.TimestampType3'):
        super(TS_NHS_TimestampType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType3')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        super(TS_NHS_TimestampType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class TS_NHS_TimestampType4(TS):
    subclass = None
    superclass = TS
    def __init__(self, nullFlavor=None, updateMode=None, value=None):
        self.original_tagname_ = None
        super(TS_NHS_TimestampType4, self).__init__(nullFlavor, updateMode, value, )
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TS_NHS_TimestampType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TS_NHS_TimestampType4.subclass:
            return TS_NHS_TimestampType4.subclass(*args_, **kwargs_)
        else:
            return TS_NHS_TimestampType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def validate_ts(self, value):
        # Validate type ts, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ts_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ts_patterns_, ))
    validate_ts_patterns_ = [['^[0-9]{1,8}$|^([0-9]{9,14}$|^[0-9]{14,14}\\.[0-9]+)([+\\-][0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            super(TS_NHS_TimestampType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TS.NHS.TimestampType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TS.NHS.TimestampType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TS.NHS.TimestampType4'):
        super(TS_NHS_TimestampType4, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TS.NHS.TimestampType4')
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TS.NHS.TimestampType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ts(self.value)    # validate type ts
        super(TS_NHS_TimestampType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class denominatorType(QTY):
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value='1', valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(denominatorType, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, denominatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if denominatorType.subclass:
            return denominatorType.subclass(*args_, **kwargs_)
        else:
            return denominatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(denominatorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='denominatorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('denominatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='denominatorType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='denominatorType'):
        super(denominatorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='denominatorType')
        if self.value != "1" and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='denominatorType', fromsubclass_=False, pretty_print=True):
        super(denominatorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(denominatorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(denominatorType, self).buildChildren(child_, node, nodeName_, True)
        pass


class numeratorType(QTY):
    subclass = None
    superclass = QTY
    def __init__(self, nullFlavor=None, updateMode=None, value='1', valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(numeratorType, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, numeratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if numeratorType.subclass:
            return numeratorType.subclass(*args_, **kwargs_)
        else:
            return numeratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(numeratorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='numeratorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numeratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='numeratorType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='numeratorType'):
        super(numeratorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='numeratorType')
        if self.value != "1" and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='numeratorType', fromsubclass_=False, pretty_print=True):
        super(numeratorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(numeratorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(numeratorType, self).buildChildren(child_, node, nodeName_, True)
        pass


class SLIST_PQ(ANY):
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, origin=None, scale=None, digits=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(SLIST_PQ, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, )
        self.origin = origin
        self.scale = scale
        self.digits = digits
        self.validate_list_int(self.digits)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIST_PQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIST_PQ.subclass:
            return SLIST_PQ.subclass(*args_, **kwargs_)
        else:
            return SLIST_PQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_scale(self): return self.scale
    def set_scale(self, scale): self.scale = scale
    def get_digits(self): return self.digits
    def set_digits(self, digits): self.digits = digits
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_list_int(self, value):
        # Validate type list_int, a restriction on int.
        pass
    def hasContent_(self):
        if (
            self.origin is not None or
            self.scale is not None or
            self.digits is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SLIST_PQ, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SLIST_PQ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIST_PQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SLIST_PQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SLIST_PQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SLIST_PQ'):
        super(SLIST_PQ, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SLIST_PQ')
    def exportChildren(self, outfile, level, namespace_='', name_='SLIST_PQ', fromsubclass_=False, pretty_print=True):
        super(SLIST_PQ, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin is not None:
            self.origin.export(outfile, level, namespace_, name_='origin', pretty_print=pretty_print)
        if self.scale is not None:
            self.scale.export(outfile, level, namespace_, name_='scale', pretty_print=pretty_print)
        if self.digits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigits>%s</%sdigits>%s' % (namespace_, self.gds_format_integer_list(self.digits, input_name='digits'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SLIST_PQ, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'origin', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_origin'):
              self.add_origin(obj_.value)
            elif hasattr(self, 'set_origin'):
              self.set_origin(obj_.value)
        elif nodeName_ == 'scale':
            obj_ = PQ.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'scale', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_scale'):
              self.add_scale(obj_.value)
            elif hasattr(self, 'set_scale'):
              self.set_scale(obj_.value)
        elif nodeName_ == 'digits' and child_.text is not None:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'digits', ival_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(SLIST_PQ, self).buildChildren(child_, node, nodeName_, True)


class URL(ANY):
    """A telecommunications address specified according to Internet
    standard RFC 1738 [http://www.ietf.org/rfc/rfc1738.txt]. The URL
    specifies the protocol and the contact point defined by that
    protocol for the resource. Notable uses of the telecommunication
    address data type are for telephone and telefax numbers, e-mail
    addresses, Hypertext references, FTP references, etc."""
    subclass = None
    superclass = ANY
    def __init__(self, nullFlavor=None, updateMode=None, value=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(URL, self).__init__(nullFlavor, updateMode, valueOf_, mixedclass_, content_, extensiontype_, )
        self.value = _cast(None, value)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL.subclass:
            return URL.subclass(*args_, **kwargs_)
        else:
            return URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_url(self, value):
        # Validate type url, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_url_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_url_patterns_, ))
    validate_url_patterns_ = [['^[\\-a-z0-9+]+:.*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(URL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL'):
        super(URL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='URL')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='URL', fromsubclass_=False, pretty_print=True):
        super(URL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_url(self.value)    # validate type url
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(URL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(URL, self).buildChildren(child_, node, nodeName_, True)
        pass


class TEL(URL):
    """A telephone number (voice or fax), e-mail address, or other locator
    for a resource (information or service) mediated by
    telecommunication equipment. The address is specified as a
    Universal Resource Locator (URL) qualified by time specification
    and use codes that help in deciding which address to use for a
    given time and purpose. One or more codes advising a system or
    user which telecommunication address in a set of like addresses
    to select for a given telecommunication need."""
    subclass = None
    superclass = URL
    def __init__(self, nullFlavor=None, updateMode=None, value=None, use=None, useablePeriod=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(TEL, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.id = id
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEL.subclass:
            return TEL.subclass(*args_, **kwargs_)
        else:
            return TEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_useablePeriod(self): return self.useablePeriod
    def set_useablePeriod(self, useablePeriod): self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value): self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value): self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value): self.useablePeriod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_TelecommunicationAddressUse(self, value):
        # Validate type set_cs_TelecommunicationAddressUse, a restriction on cs_TelecommunicationAddressUse.
        pass
    def hasContent_(self):
        if (
            self.useablePeriod or
            self.id is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TEL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEL'):
        super(TEL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TEL')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TEL', fromsubclass_=False, pretty_print=True):
        super(TEL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for useablePeriod_ in self.useablePeriod:
            useablePeriod_.export(outfile, level, namespace_, name_='useablePeriod', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_TelecommunicationAddressUse(self.use)    # validate type set_cs_TelecommunicationAddressUse
        super(TEL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'useablePeriod':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'id', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_id'):
              self.add_id(obj_.value)
            elif hasattr(self, 'set_id'):
              self.set_id(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TEL, self).buildChildren(child_, node, nodeName_, True)


class TEL_NPFIT_use_required(URL):
    subclass = None
    superclass = URL
    def __init__(self, nullFlavor=None, updateMode=None, value=None, use=None, useablePeriod=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(TEL_NPFIT_use_required, self).__init__(nullFlavor, updateMode, value, valueOf_, mixedclass_, content_, )
        self.use = _cast(None, use)
        if useablePeriod is None:
            self.useablePeriod = []
        else:
            self.useablePeriod = useablePeriod
        self.id = id
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEL_NPFIT_use_required)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEL_NPFIT_use_required.subclass:
            return TEL_NPFIT_use_required.subclass(*args_, **kwargs_)
        else:
            return TEL_NPFIT_use_required(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_useablePeriod(self): return self.useablePeriod
    def set_useablePeriod(self, useablePeriod): self.useablePeriod = useablePeriod
    def add_useablePeriod(self, value): self.useablePeriod.append(value)
    def insert_useablePeriod_at(self, index, value): self.useablePeriod.insert(index, value)
    def replace_useablePeriod_at(self, index, value): self.useablePeriod[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_use(self): return self.use
    def set_use(self, use): self.use = use
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_set_cs_TelecommunicationAddressUse(self, value):
        # Validate type set_cs_TelecommunicationAddressUse, a restriction on cs_TelecommunicationAddressUse.
        pass
    def hasContent_(self):
        if (
            self.useablePeriod or
            self.id is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TEL_NPFIT_use_required, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEL.NPFIT.use.required', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEL.NPFIT.use.required')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEL.NPFIT.use.required')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEL.NPFIT.use.required', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEL.NPFIT.use.required'):
        super(TEL_NPFIT_use_required, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TEL.NPFIT.use.required')
        if self.use is not None and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TEL.NPFIT.use.required', fromsubclass_=False, pretty_print=True):
        super(TEL_NPFIT_use_required, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for useablePeriod_ in self.useablePeriod:
            useablePeriod_.export(outfile, level, namespace_, name_='useablePeriod', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_set_cs_TelecommunicationAddressUse(self.use)    # validate type set_cs_TelecommunicationAddressUse
        super(TEL_NPFIT_use_required, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'useablePeriod':
            obj_ = IVL_TS.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'useablePeriod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_useablePeriod'):
              self.add_useablePeriod(obj_.value)
            elif hasattr(self, 'set_useablePeriod'):
              self.set_useablePeriod(obj_.value)
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'id', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_id'):
              self.add_id(obj_.value)
            elif hasattr(self, 'set_id'):
              self.set_id(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TEL_NPFIT_use_required, self).buildChildren(child_, node, nodeName_, True)


class GPPractice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, addr=None, telecom=None, locationOrganization=None):
        self.original_tagname_ = None
        self.classCode = _cast(None, classCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.addr = addr
        self.telecom = telecom
        self.locationOrganization = locationOrganization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GPPractice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GPPractice.subclass:
            return GPPractice.subclass(*args_, **kwargs_)
        else:
            return GPPractice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_addr(self): return self.addr
    def set_addr(self, addr): self.addr = addr
    def get_telecom(self): return self.telecom
    def set_telecom(self, telecom): self.telecom = telecom
    def get_locationOrganization(self): return self.locationOrganization
    def set_locationOrganization(self, locationOrganization): self.locationOrganization = locationOrganization
    def get_classCode(self): return self.classCode
    def set_classCode(self, classCode): self.classCode = classCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.addr is not None or
            self.telecom is not None or
            self.locationOrganization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.GPPractice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000016GB01.GPPractice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000016GB01.GPPractice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000016GB01.GPPractice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000016GB01.GPPractice'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.GPPractice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.addr is not None:
            self.addr.export(outfile, level, namespace_, name_='addr', pretty_print=pretty_print)
        if self.telecom is not None:
            self.telecom.export(outfile, level, namespace_, name_='telecom', pretty_print=pretty_print)
        if self.locationOrganization is not None:
            self.locationOrganization.export(outfile, level, namespace_, name_='locationOrganization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_cs(self.classCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'addr':
            obj_ = AD_NHS_AddressType2.factory()
            obj_.build(child_)
            self.addr = obj_
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory()
            obj_.build(child_)
            self.telecom = obj_
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'locationOrganization':
            obj_ = Organization.factory()
            obj_.build(child_)
            self.locationOrganization = obj_
            obj_.original_tagname_ = 'locationOrganization'


class Organization(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classCode=None, determinerCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, id=None, name=None):
        self.original_tagname_ = None
        self.classCode = _cast(None, classCode)
        self.determinerCode = _cast(None, determinerCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Organization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Organization.subclass:
            return Organization.subclass(*args_, **kwargs_)
        else:
            return Organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_classCode(self): return self.classCode
    def set_classCode(self, classCode): self.classCode = classCode
    def get_determinerCode(self): return self.determinerCode
    def set_determinerCode(self, determinerCode): self.determinerCode = determinerCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Organization', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000016GB01.Organization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000016GB01.Organization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000016GB01.Organization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000016GB01.Organization'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Organization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_cs(self.classCode)    # validate type cs
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.validate_cs(self.determinerCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II_NHS_IdentifierType3.factory()
            obj_.build(child_)
            self.id = obj_
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = ON.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'


class PQ_inc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, unit='1', originalValue=None, originalUnit=None, nullFlavor=None, inclusive='true', updateMode=None, translation=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
        self.originalValue = _cast(None, originalValue)
        self.originalUnit = _cast(None, originalUnit)
        self.nullFlavor = _cast(None, nullFlavor)
        self.inclusive = _cast(None, inclusive)
        self.updateMode = _cast(None, updateMode)
        if translation is None:
            self.translation = []
        else:
            self.translation = translation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PQ_inc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PQ_inc.subclass:
            return PQ_inc.subclass(*args_, **kwargs_)
        else:
            return PQ_inc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_translation(self): return self.translation
    def set_translation(self, translation): self.translation = translation
    def add_translation(self, value): self.translation.append(value)
    def insert_translation_at(self, index, value): self.translation.insert(index, value)
    def replace_translation_at(self, index, value): self.translation[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_originalValue(self): return self.originalValue
    def set_originalValue(self, originalValue): self.originalValue = originalValue
    def get_originalUnit(self): return self.originalUnit
    def set_originalUnit(self, originalUnit): self.originalUnit = originalUnit
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_inclusive(self): return self.inclusive
    def set_inclusive(self, inclusive): self.inclusive = inclusive
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_real(self, value):
        # Validate type real, a restriction on None.
        pass
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_cs_NullFlavor(self, value):
        # Validate type cs_NullFlavor, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NI', 'NA', 'UNK', 'NASK', 'ASKU', 'NAV', 'OTH', 'PINF', 'NINF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_NullFlavor' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_NullFlavor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_NullFlavor_patterns_, ))
    validate_cs_NullFlavor_patterns_ = [['^[^\\s]*$']]
    def validate_bl(self, value):
        # Validate type bl, a restriction on xsd:boolean.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_bl_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_bl_patterns_, ))
    validate_bl_patterns_ = [['^true$|^false$']]
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.translation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PQ_inc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PQ_inc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PQ_inc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PQ_inc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PQ_inc'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit != "1" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.originalValue is not None and 'originalValue' not in already_processed:
            already_processed.add('originalValue')
            outfile.write(' originalValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.originalValue), input_name='originalValue')), ))
        if self.originalUnit is not None and 'originalUnit' not in already_processed:
            already_processed.add('originalUnit')
            outfile.write(' originalUnit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.originalUnit), input_name='originalUnit')), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.inclusive != "true" and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive=%s' % (quote_attrib(self.inclusive), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PQ_inc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for translation_ in self.translation:
            translation_.export(outfile, level, namespace_, name_='translation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_real(self.value)    # validate type real
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_cs(self.unit)    # validate type cs
        value = find_attr_value_('originalValue', node)
        if value is not None and 'originalValue' not in already_processed:
            already_processed.add('originalValue')
            self.originalValue = value
        value = find_attr_value_('originalUnit', node)
        if value is not None and 'originalUnit' not in already_processed:
            already_processed.add('originalUnit')
            self.originalUnit = value
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_cs_NullFlavor(self.nullFlavor)    # validate type cs_NullFlavor
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            self.inclusive = value
            self.validate_bl(self.inclusive)    # validate type bl
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'translation':
            obj_ = PQR.factory()
            obj_.build(child_)
            self.translation.append(obj_)
            obj_.original_tagname_ = 'translation'


class Patient(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, id=None, name=None, addr=None, telecom=None, patientPerson=None):
        self.original_tagname_ = None
        self.classCode = _cast(None, classCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        if id is None:
            self.id = []
        else:
            self.id = id
        self.name = name
        if addr is None:
            self.addr = []
        else:
            self.addr = addr
        if telecom is None:
            self.telecom = []
        else:
            self.telecom = telecom
        self.patientPerson = patientPerson
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Patient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Patient.subclass:
            return Patient.subclass(*args_, **kwargs_)
        else:
            return Patient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def add_id(self, value): self.id.append(value)
    def insert_id_at(self, index, value): self.id.insert(index, value)
    def replace_id_at(self, index, value): self.id[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_addr(self): return self.addr
    def set_addr(self, addr): self.addr = addr
    def add_addr(self, value): self.addr.append(value)
    def insert_addr_at(self, index, value): self.addr.insert(index, value)
    def replace_addr_at(self, index, value): self.addr[index] = value
    def get_telecom(self): return self.telecom
    def set_telecom(self, telecom): self.telecom = telecom
    def add_telecom(self, value): self.telecom.append(value)
    def insert_telecom_at(self, index, value): self.telecom.insert(index, value)
    def replace_telecom_at(self, index, value): self.telecom[index] = value
    def get_patientPerson(self): return self.patientPerson
    def set_patientPerson(self, patientPerson): self.patientPerson = patientPerson
    def get_classCode(self): return self.classCode
    def set_classCode(self, classCode): self.classCode = classCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.id or
            self.name is not None or
            self.addr or
            self.telecom or
            self.patientPerson is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Patient', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000016GB01.Patient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000016GB01.Patient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000016GB01.Patient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000016GB01.Patient'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Patient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        for id_ in self.id:
            id_.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        for addr_ in self.addr:
            addr_.export(outfile, level, namespace_, name_='addr', pretty_print=pretty_print)
        for telecom_ in self.telecom:
            telecom_.export(outfile, level, namespace_, name_='telecom', pretty_print=pretty_print)
        if self.patientPerson is not None:
            self.patientPerson.export(outfile, level, namespace_, name_='patientPerson', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_cs(self.classCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'id':
            obj_ = II.factory()
            obj_.build(child_)
            self.id.append(obj_)
            obj_.original_tagname_ = 'id'
        elif nodeName_ == 'name':
            obj_ = PN_NHS_PersonNameType2.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'addr':
            obj_ = AD_NHS_AddressType2.factory()
            obj_.build(child_)
            self.addr.append(obj_)
            obj_.original_tagname_ = 'addr'
        elif nodeName_ == 'telecom':
            obj_ = TEL.factory()
            obj_.build(child_)
            self.telecom.append(obj_)
            obj_.original_tagname_ = 'telecom'
        elif nodeName_ == 'patientPerson':
            obj_ = Person.factory()
            obj_.build(child_)
            self.patientPerson = obj_
            obj_.original_tagname_ = 'patientPerson'


class Person(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classCode=None, determinerCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, administrativeGenderCode=None, birthTime=None, deceasedTime=None, gPPractice=None):
        self.original_tagname_ = None
        self.classCode = _cast(None, classCode)
        self.determinerCode = _cast(None, determinerCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.administrativeGenderCode = administrativeGenderCode
        self.birthTime = birthTime
        self.deceasedTime = deceasedTime
        self.gPPractice = gPPractice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_administrativeGenderCode(self): return self.administrativeGenderCode
    def set_administrativeGenderCode(self, administrativeGenderCode): self.administrativeGenderCode = administrativeGenderCode
    def get_birthTime(self): return self.birthTime
    def set_birthTime(self, birthTime): self.birthTime = birthTime
    def get_deceasedTime(self): return self.deceasedTime
    def set_deceasedTime(self, deceasedTime): self.deceasedTime = deceasedTime
    def get_gPPractice(self): return self.gPPractice
    def set_gPPractice(self, gPPractice): self.gPPractice = gPPractice
    def get_classCode(self): return self.classCode
    def set_classCode(self, classCode): self.classCode = classCode
    def get_determinerCode(self): return self.determinerCode
    def set_determinerCode(self, determinerCode): self.determinerCode = determinerCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.administrativeGenderCode is not None or
            self.birthTime is not None or
            self.deceasedTime is not None or
            self.gPPractice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Person', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000016GB01.Person')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000016GB01.Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000016GB01.Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000016GB01.Person'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.determinerCode is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            outfile.write(' determinerCode=%s' % (quote_attrib(self.determinerCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.administrativeGenderCode is not None:
            self.administrativeGenderCode.export(outfile, level, namespace_, name_='administrativeGenderCode', pretty_print=pretty_print)
        if self.birthTime is not None:
            self.birthTime.export(outfile, level, namespace_, name_='birthTime', pretty_print=pretty_print)
        if self.deceasedTime is not None:
            self.deceasedTime.export(outfile, level, namespace_, name_='deceasedTime', pretty_print=pretty_print)
        if self.gPPractice is not None:
            self.gPPractice.export(outfile, level, namespace_, name_='gPPractice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_cs(self.classCode)    # validate type cs
        value = find_attr_value_('determinerCode', node)
        if value is not None and 'determinerCode' not in already_processed:
            already_processed.add('determinerCode')
            self.determinerCode = value
            self.validate_cs(self.determinerCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'administrativeGenderCode':
            obj_ = administrativeGenderCodeType.factory()
            obj_.build(child_)
            self.administrativeGenderCode = obj_
            obj_.original_tagname_ = 'administrativeGenderCode'
        elif nodeName_ == 'birthTime':
            obj_ = TS_NHS_TimestampType3.factory()
            obj_.build(child_)
            self.birthTime = obj_
            obj_.original_tagname_ = 'birthTime'
        elif nodeName_ == 'deceasedTime':
            obj_ = TS_NHS_TimestampType1.factory()
            obj_.build(child_)
            self.deceasedTime = obj_
            obj_.original_tagname_ = 'deceasedTime'
        elif nodeName_ == 'gPPractice':
            obj_ = GPPractice.factory()
            obj_.build(child_)
            self.gPPractice = obj_
            obj_.original_tagname_ = 'gPPractice'


class StrucDoc_Br(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Br)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Br.subclass:
            return StrucDoc_Br.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Br(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Br', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Br')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Br')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Br', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Br'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Br', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class StrucDoc_Caption(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, linkHtml=None, sub=None, sup=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Caption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Caption.subclass:
            return StrucDoc_Caption.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.linkHtml or
            self.sub or
            self.sup or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Caption', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Caption')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Caption')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Caption', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Caption'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Caption', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_Col(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, span='1', width=None, align=None, char=None, charoff=None, valign=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.span = _cast(None, span)
        self.width = _cast(None, width)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Col)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Col.subclass:
            return StrucDoc_Col.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Col(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_span(self): return self.span
    def set_span(self, span): self.span = span
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Col', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Col')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Col')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Col', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Col'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Col', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class StrucDoc_Colgroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, span='1', width=None, align=None, char=None, charoff=None, valign=None, col=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.span = _cast(None, span)
        self.width = _cast(None, width)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if col is None:
            self.col = []
        else:
            self.col = col
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Colgroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Colgroup.subclass:
            return StrucDoc_Colgroup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Colgroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_col(self): return self.col
    def set_col(self, col): self.col = col
    def add_col(self, value): self.col.append(value)
    def insert_col_at(self, index, value): self.col.insert(index, value)
    def replace_col_at(self, index, value): self.col[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_span(self): return self.span
    def set_span(self, span): self.span = span
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def hasContent_(self):
        if (
            self.col
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Colgroup', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Colgroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Colgroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Colgroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Colgroup'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.span != "1" and 'span' not in already_processed:
            already_processed.add('span')
            outfile.write(' span=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.span), input_name='span')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Colgroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for col_ in self.col:
            col_.export(outfile, level, namespace_, name_='col', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.add('span')
            self.span = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory()
            obj_.build(child_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'


class StrucDoc_Content(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, revised=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.revised = _cast(None, revised)
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Content)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Content.subclass:
            return StrucDoc_Content.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Content(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_revised(self): return self.revised
    def set_revised(self, revised): self.revised = revised
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Content', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Content')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Content')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Content', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Content'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.revised is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            outfile.write(' revised=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.revised), input_name='revised')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Content', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('revised', node)
        if value is not None and 'revised' not in already_processed:
            already_processed.add('revised')
            self.revised = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_Footnote(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, content=None, linkHtml=None, sub=None, sup=None, br=None, renderMultiMedia=None, paragraph=None, list=None, table=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        if list is None:
            self.list = []
        else:
            self.list = list
        if table is None:
            self.table = []
        else:
            self.table = table
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Footnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Footnote.subclass:
            return StrucDoc_Footnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Footnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_paragraph(self): return self.paragraph
    def set_paragraph(self, paragraph): self.paragraph = paragraph
    def add_paragraph(self, value): self.paragraph.append(value)
    def insert_paragraph_at(self, index, value): self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value): self.paragraph[index] = value
    def get_list(self): return self.list
    def set_list(self, list): self.list = list
    def add_list(self, value): self.list.append(value)
    def insert_list_at(self, index, value): self.list.insert(index, value)
    def replace_list_at(self, index, value): self.list[index] = value
    def get_table(self): return self.table
    def set_table(self, table): self.table = table
    def add_table(self, value): self.table.append(value)
    def insert_table_at(self, index, value): self.table.insert(index, value)
    def replace_table_at(self, index, value): self.table[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Footnote', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Footnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Footnote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Footnote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Footnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Footnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            paragraph_.export(outfile, level, namespace_, name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            list_.export(outfile, level, namespace_, name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            table_.export(outfile, level, namespace_, name_='table', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_FootnoteRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, IDREF=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.IDREF = _cast(None, IDREF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_FootnoteRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_FootnoteRef.subclass:
            return StrucDoc_FootnoteRef.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_FootnoteRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_IDREF(self): return self.IDREF
    def set_IDREF(self, IDREF): self.IDREF = IDREF
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.FootnoteRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.FootnoteRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.FootnoteRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.FootnoteRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.FootnoteRef'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.IDREF is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            outfile.write(' IDREF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDREF), input_name='IDREF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.FootnoteRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('IDREF', node)
        if value is not None and 'IDREF' not in already_processed:
            already_processed.add('IDREF')
            self.IDREF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class StrucDoc_Item(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, caption=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, paragraph=None, list=None, table=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.caption = caption
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        if list is None:
            self.list = []
        else:
            self.list = list
        if table is None:
            self.table = []
        else:
            self.table = table
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Item.subclass:
            return StrucDoc_Item.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_paragraph(self): return self.paragraph
    def set_paragraph(self, paragraph): self.paragraph = paragraph
    def add_paragraph(self, value): self.paragraph.append(value)
    def insert_paragraph_at(self, index, value): self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value): self.paragraph[index] = value
    def get_list(self): return self.list
    def set_list(self, list): self.list = list
    def add_list(self, value): self.list.append(value)
    def insert_list_at(self, index, value): self.list.insert(index, value)
    def replace_list_at(self, index, value): self.list[index] = value
    def get_table(self): return self.table
    def set_table(self, table): self.table = table
    def add_table(self, value): self.table.append(value)
    def insert_table_at(self, index, value): self.table.insert(index, value)
    def replace_table_at(self, index, value): self.table[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Item', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Item')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Item', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Item'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Item', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            self.caption.export(outfile, level, namespace_, name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            paragraph_.export(outfile, level, namespace_, name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            list_.export(outfile, level, namespace_, name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            table_.export(outfile, level, namespace_, name_='table', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_LinkHtml(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, href=None, rel=None, rev=None, title=None, ID=None, language=None, styleCode=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.href = _cast(None, href)
        self.rel = _cast(None, rel)
        self.rev = _cast(None, rev)
        self.title = _cast(None, title)
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_LinkHtml)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_LinkHtml.subclass:
            return StrucDoc_LinkHtml.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_LinkHtml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def get_rev(self): return self.rev
    def set_rev(self, rev): self.rev = rev
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.LinkHtml', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.LinkHtml')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.LinkHtml')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.LinkHtml', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.LinkHtml'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rel), input_name='rel')), ))
        if self.rev is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            outfile.write(' rev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rev), input_name='rev')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.LinkHtml', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        value = find_attr_value_('rev', node)
        if value is not None and 'rev' not in already_processed:
            already_processed.add('rev')
            self.rev = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_List(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, listType='unordered', caption=None, item=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.listType = _cast(None, listType)
        self.caption = caption
        if item is None:
            self.item = []
        else:
            self.item = item
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_List)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_List.subclass:
            return StrucDoc_List.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_List(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def add_item(self, value): self.item.append(value)
    def insert_item_at(self, index, value): self.item.insert(index, value)
    def replace_item_at(self, index, value): self.item[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_listType(self): return self.listType
    def set_listType(self, listType): self.listType = listType
    def hasContent_(self):
        if (
            self.caption is not None or
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.List', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.List')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.List')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.List', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.List'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.listType != "unordered" and 'listType' not in already_processed:
            already_processed.add('listType')
            outfile.write(' listType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.listType), input_name='listType')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.List', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            self.caption.export(outfile, level, namespace_, name_='caption', pretty_print=pretty_print)
        for item_ in self.item:
            item_.export(outfile, level, namespace_, name_='item', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('listType', node)
        if value is not None and 'listType' not in already_processed:
            already_processed.add('listType')
            self.listType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory()
            obj_.build(child_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'item':
            obj_ = StrucDoc_Item.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'


class StrucDoc_Paragraph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, caption=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.caption = caption
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Paragraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Paragraph.subclass:
            return StrucDoc_Paragraph.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Paragraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.caption is not None or
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Paragraph', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Paragraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Paragraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Paragraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Paragraph'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Paragraph', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            self.caption.export(outfile, level, namespace_, name_='caption', pretty_print=pretty_print)
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'caption', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_caption'):
              self.add_caption(obj_.value)
            elif hasattr(self, 'set_caption'):
              self.set_caption(obj_.value)
        elif nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_RenderMultiMedia(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, referencedObject=None, ID=None, language=None, styleCode=None, caption=None):
        self.original_tagname_ = None
        self.referencedObject = _cast(None, referencedObject)
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.caption = caption
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_RenderMultiMedia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_RenderMultiMedia.subclass:
            return StrucDoc_RenderMultiMedia.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_RenderMultiMedia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_referencedObject(self): return self.referencedObject
    def set_referencedObject(self, referencedObject): self.referencedObject = referencedObject
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def hasContent_(self):
        if (
            self.caption is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.RenderMultiMedia', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.RenderMultiMedia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.RenderMultiMedia')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.RenderMultiMedia', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.RenderMultiMedia'):
        if self.referencedObject is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            outfile.write(' referencedObject=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.referencedObject), input_name='referencedObject')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.RenderMultiMedia', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            self.caption.export(outfile, level, namespace_, name_='caption', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referencedObject', node)
        if value is not None and 'referencedObject' not in already_processed:
            already_processed.add('referencedObject')
            self.referencedObject = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory()
            obj_.build(child_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'


class StrucDoc_Sub(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sub.subclass:
            return StrucDoc_Sub.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Sub', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sub')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Sub')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Sub'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Sub', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class StrucDoc_Sup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Sup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Sup.subclass:
            return StrucDoc_Sup.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Sup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Sup', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Sup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Sup')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Sup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Sup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class StrucDoc_Table(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, summary=None, width=None, border=None, frame=None, rules=None, cellspacing=None, cellpadding=None, caption=None, col=None, colgroup=None, thead=None, tfoot=None, tbody=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.summary = _cast(None, summary)
        self.width = _cast(None, width)
        self.border = _cast(None, border)
        self.frame = _cast(None, frame)
        self.rules = _cast(None, rules)
        self.cellspacing = _cast(None, cellspacing)
        self.cellpadding = _cast(None, cellpadding)
        self.caption = caption
        if col is None:
            self.col = []
        else:
            self.col = col
        if colgroup is None:
            self.colgroup = []
        else:
            self.colgroup = colgroup
        self.thead = thead
        self.tfoot = tfoot
        if tbody is None:
            self.tbody = []
        else:
            self.tbody = tbody
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Table)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Table.subclass:
            return StrucDoc_Table.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Table(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_col(self): return self.col
    def set_col(self, col): self.col = col
    def add_col(self, value): self.col.append(value)
    def insert_col_at(self, index, value): self.col.insert(index, value)
    def replace_col_at(self, index, value): self.col[index] = value
    def get_colgroup(self): return self.colgroup
    def set_colgroup(self, colgroup): self.colgroup = colgroup
    def add_colgroup(self, value): self.colgroup.append(value)
    def insert_colgroup_at(self, index, value): self.colgroup.insert(index, value)
    def replace_colgroup_at(self, index, value): self.colgroup[index] = value
    def get_thead(self): return self.thead
    def set_thead(self, thead): self.thead = thead
    def get_tfoot(self): return self.tfoot
    def set_tfoot(self, tfoot): self.tfoot = tfoot
    def get_tbody(self): return self.tbody
    def set_tbody(self, tbody): self.tbody = tbody
    def add_tbody(self, value): self.tbody.append(value)
    def insert_tbody_at(self, index, value): self.tbody.insert(index, value)
    def replace_tbody_at(self, index, value): self.tbody[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_summary(self): return self.summary
    def set_summary(self, summary): self.summary = summary
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_border(self): return self.border
    def set_border(self, border): self.border = border
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def get_rules(self): return self.rules
    def set_rules(self, rules): self.rules = rules
    def get_cellspacing(self): return self.cellspacing
    def set_cellspacing(self, cellspacing): self.cellspacing = cellspacing
    def get_cellpadding(self): return self.cellpadding
    def set_cellpadding(self, cellpadding): self.cellpadding = cellpadding
    def hasContent_(self):
        if (
            self.caption is not None or
            self.col or
            self.colgroup or
            self.thead is not None or
            self.tfoot is not None or
            self.tbody
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Table', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Table')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Table')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Table', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Table'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            outfile.write(' summary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.summary), input_name='summary')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.border is not None and 'border' not in already_processed:
            already_processed.add('border')
            outfile.write(' border=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.border), input_name='border')), ))
        if self.frame is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            outfile.write(' frame=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.frame), input_name='frame')), ))
        if self.rules is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            outfile.write(' rules=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rules), input_name='rules')), ))
        if self.cellspacing is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            outfile.write(' cellspacing=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellspacing), input_name='cellspacing')), ))
        if self.cellpadding is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            outfile.write(' cellpadding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellpadding), input_name='cellpadding')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Table', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            self.caption.export(outfile, level, namespace_, name_='caption', pretty_print=pretty_print)
        for col_ in self.col:
            col_.export(outfile, level, namespace_, name_='col', pretty_print=pretty_print)
        for colgroup_ in self.colgroup:
            colgroup_.export(outfile, level, namespace_, name_='colgroup', pretty_print=pretty_print)
        if self.thead is not None:
            self.thead.export(outfile, level, namespace_, name_='thead', pretty_print=pretty_print)
        if self.tfoot is not None:
            self.tfoot.export(outfile, level, namespace_, name_='tfoot', pretty_print=pretty_print)
        for tbody_ in self.tbody:
            tbody_.export(outfile, level, namespace_, name_='tbody', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('summary', node)
        if value is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            self.summary = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('border', node)
        if value is not None and 'border' not in already_processed:
            already_processed.add('border')
            self.border = value
        value = find_attr_value_('frame', node)
        if value is not None and 'frame' not in already_processed:
            already_processed.add('frame')
            self.frame = value
        value = find_attr_value_('rules', node)
        if value is not None and 'rules' not in already_processed:
            already_processed.add('rules')
            self.rules = value
        value = find_attr_value_('cellspacing', node)
        if value is not None and 'cellspacing' not in already_processed:
            already_processed.add('cellspacing')
            self.cellspacing = value
        value = find_attr_value_('cellpadding', node)
        if value is not None and 'cellpadding' not in already_processed:
            already_processed.add('cellpadding')
            self.cellpadding = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caption':
            obj_ = StrucDoc_Caption.factory()
            obj_.build(child_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'col':
            obj_ = StrucDoc_Col.factory()
            obj_.build(child_)
            self.col.append(obj_)
            obj_.original_tagname_ = 'col'
        elif nodeName_ == 'colgroup':
            obj_ = StrucDoc_Colgroup.factory()
            obj_.build(child_)
            self.colgroup.append(obj_)
            obj_.original_tagname_ = 'colgroup'
        elif nodeName_ == 'thead':
            obj_ = StrucDoc_Thead.factory()
            obj_.build(child_)
            self.thead = obj_
            obj_.original_tagname_ = 'thead'
        elif nodeName_ == 'tfoot':
            obj_ = StrucDoc_Tfoot.factory()
            obj_.build(child_)
            self.tfoot = obj_
            obj_.original_tagname_ = 'tfoot'
        elif nodeName_ == 'tbody':
            obj_ = StrucDoc_Tbody.factory()
            obj_.build(child_)
            self.tbody.append(obj_)
            obj_.original_tagname_ = 'tbody'


class StrucDoc_Tbody(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, tr=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tbody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tbody.subclass:
            return StrucDoc_Tbody.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tbody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Tbody', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tbody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Tbody')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Tbody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Tbody'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Tbody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class StrucDoc_Td(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, abbr=None, axis=None, headers=None, scope=None, rowspan='1', colspan='1', align=None, char=None, charoff=None, valign=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, paragraph=None, list=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.abbr = _cast(None, abbr)
        self.axis = _cast(None, axis)
        self.headers = _cast(None, headers)
        self.scope = _cast(None, scope)
        self.rowspan = _cast(None, rowspan)
        self.colspan = _cast(None, colspan)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        if list is None:
            self.list = []
        else:
            self.list = list
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Td)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Td.subclass:
            return StrucDoc_Td.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Td(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_paragraph(self): return self.paragraph
    def set_paragraph(self, paragraph): self.paragraph = paragraph
    def add_paragraph(self, value): self.paragraph.append(value)
    def insert_paragraph_at(self, index, value): self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value): self.paragraph[index] = value
    def get_list(self): return self.list
    def set_list(self, list): self.list = list
    def add_list(self, value): self.list.append(value)
    def insert_list_at(self, index, value): self.list.insert(index, value)
    def replace_list_at(self, index, value): self.list[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_abbr(self): return self.abbr
    def set_abbr(self, abbr): self.abbr = abbr
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def get_headers(self): return self.headers
    def set_headers(self, headers): self.headers = headers
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def get_rowspan(self): return self.rowspan
    def set_rowspan(self, rowspan): self.rowspan = rowspan
    def get_colspan(self): return self.colspan
    def set_colspan(self, colspan): self.colspan = colspan
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Td', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Td')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Td')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Td', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Td'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Td', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            paragraph_.export(outfile, level, namespace_, name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            list_.export(outfile, level, namespace_, name_='list', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_Text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, mediaType=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, paragraph=None, list=None, table=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.mediaType = _cast(None, mediaType)
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        if paragraph is None:
            self.paragraph = []
        else:
            self.paragraph = paragraph
        if list is None:
            self.list = []
        else:
            self.list = list
        if table is None:
            self.table = []
        else:
            self.table = table
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Text.subclass:
            return StrucDoc_Text.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_paragraph(self): return self.paragraph
    def set_paragraph(self, paragraph): self.paragraph = paragraph
    def add_paragraph(self, value): self.paragraph.append(value)
    def insert_paragraph_at(self, index, value): self.paragraph.insert(index, value)
    def replace_paragraph_at(self, index, value): self.paragraph[index] = value
    def get_list(self): return self.list
    def set_list(self, list): self.list = list
    def add_list(self, value): self.list.append(value)
    def insert_list_at(self, index, value): self.list.insert(index, value)
    def replace_list_at(self, index, value): self.list[index] = value
    def get_table(self): return self.table
    def set_table(self, table): self.table = table
    def add_table(self, value): self.table.append(value)
    def insert_table_at(self, index, value): self.table.insert(index, value)
    def replace_table_at(self, index, value): self.table[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_mediaType(self): return self.mediaType
    def set_mediaType(self, mediaType): self.mediaType = mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            self.paragraph or
            self.list or
            self.table or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Text', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Text')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Text', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Text'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Text', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
        for paragraph_ in self.paragraph:
            paragraph_.export(outfile, level, namespace_, name_='paragraph', pretty_print=pretty_print)
        for list_ in self.list:
            list_.export(outfile, level, namespace_, name_='list', pretty_print=pretty_print)
        for table_ in self.table:
            table_.export(outfile, level, namespace_, name_='table', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        elif nodeName_ == 'paragraph':
            obj_ = StrucDoc_Paragraph.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'paragraph', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_paragraph'):
              self.add_paragraph(obj_.value)
            elif hasattr(self, 'set_paragraph'):
              self.set_paragraph(obj_.value)
        elif nodeName_ == 'list':
            obj_ = StrucDoc_List.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'list', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_list'):
              self.add_list(obj_.value)
            elif hasattr(self, 'set_list'):
              self.set_list(obj_.value)
        elif nodeName_ == 'table':
            obj_ = StrucDoc_Table.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_Tfoot(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, tr=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tfoot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tfoot.subclass:
            return StrucDoc_Tfoot.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tfoot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Tfoot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tfoot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Tfoot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Tfoot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Tfoot'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Tfoot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class StrucDoc_Th(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, abbr=None, axis=None, headers=None, scope=None, rowspan='1', colspan='1', align=None, char=None, charoff=None, valign=None, content=None, linkHtml=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, renderMultiMedia=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.abbr = _cast(None, abbr)
        self.axis = _cast(None, axis)
        self.headers = _cast(None, headers)
        self.scope = _cast(None, scope)
        self.rowspan = _cast(None, rowspan)
        self.colspan = _cast(None, colspan)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if content is None:
            self.content = []
        else:
            self.content = content
        if linkHtml is None:
            self.linkHtml = []
        else:
            self.linkHtml = linkHtml
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        if renderMultiMedia is None:
            self.renderMultiMedia = []
        else:
            self.renderMultiMedia = renderMultiMedia
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Th)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Th.subclass:
            return StrucDoc_Th.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Th(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_linkHtml(self): return self.linkHtml
    def set_linkHtml(self, linkHtml): self.linkHtml = linkHtml
    def add_linkHtml(self, value): self.linkHtml.append(value)
    def insert_linkHtml_at(self, index, value): self.linkHtml.insert(index, value)
    def replace_linkHtml_at(self, index, value): self.linkHtml[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_renderMultiMedia(self): return self.renderMultiMedia
    def set_renderMultiMedia(self, renderMultiMedia): self.renderMultiMedia = renderMultiMedia
    def add_renderMultiMedia(self, value): self.renderMultiMedia.append(value)
    def insert_renderMultiMedia_at(self, index, value): self.renderMultiMedia.insert(index, value)
    def replace_renderMultiMedia_at(self, index, value): self.renderMultiMedia[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_abbr(self): return self.abbr
    def set_abbr(self, abbr): self.abbr = abbr
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def get_headers(self): return self.headers
    def set_headers(self, headers): self.headers = headers
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def get_rowspan(self): return self.rowspan
    def set_rowspan(self, rowspan): self.rowspan = rowspan
    def get_colspan(self): return self.colspan
    def set_colspan(self, colspan): self.colspan = colspan
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.linkHtml or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            self.renderMultiMedia or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Th', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Th')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Th')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Th', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Th'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
        if self.rowspan != "1" and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan != "1" and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Th', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for linkHtml_ in self.linkHtml:
            linkHtml_.export(outfile, level, namespace_, name_='linkHtml', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
        for renderMultiMedia_ in self.renderMultiMedia:
            renderMultiMedia_.export(outfile, level, namespace_, name_='renderMultiMedia', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_Content.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'linkHtml':
            obj_ = StrucDoc_LinkHtml.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linkHtml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linkHtml'):
              self.add_linkHtml(obj_.value)
            elif hasattr(self, 'set_linkHtml'):
              self.set_linkHtml(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_Footnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        elif nodeName_ == 'renderMultiMedia':
            obj_ = StrucDoc_RenderMultiMedia.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'renderMultiMedia', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_renderMultiMedia'):
              self.add_renderMultiMedia(obj_.value)
            elif hasattr(self, 'set_renderMultiMedia'):
              self.set_renderMultiMedia(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_Thead(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, tr=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Thead)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Thead.subclass:
            return StrucDoc_Thead.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Thead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Thead', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Thead')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Thead')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Thead', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Thead'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Thead', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tr':
            obj_ = StrucDoc_Tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class StrucDoc_Title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, mediaType=None, content=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.mediaType = _cast(None, mediaType)
        if content is None:
            self.content = []
        else:
            self.content = content
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Title)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Title.subclass:
            return StrucDoc_Title.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_mediaType(self): return self.mediaType
    def set_mediaType(self, mediaType): self.mediaType = mediaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Title', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Title')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Title', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Title'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Title', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_TitleContent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, content=None, sub=None, sup=None, br=None, footnote=None, footnoteRef=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        if content is None:
            self.content = []
        else:
            self.content = content
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        if footnote is None:
            self.footnote = []
        else:
            self.footnote = footnote
        if footnoteRef is None:
            self.footnoteRef = []
        else:
            self.footnoteRef = footnoteRef
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleContent.subclass:
            return StrucDoc_TitleContent.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_footnote(self): return self.footnote
    def set_footnote(self, footnote): self.footnote = footnote
    def add_footnote(self, value): self.footnote.append(value)
    def insert_footnote_at(self, index, value): self.footnote.insert(index, value)
    def replace_footnote_at(self, index, value): self.footnote[index] = value
    def get_footnoteRef(self): return self.footnoteRef
    def set_footnoteRef(self, footnoteRef): self.footnoteRef = footnoteRef
    def add_footnoteRef(self, value): self.footnoteRef.append(value)
    def insert_footnoteRef_at(self, index, value): self.footnoteRef.insert(index, value)
    def replace_footnoteRef_at(self, index, value): self.footnoteRef[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            self.footnote or
            self.footnoteRef or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.TitleContent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.TitleContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.TitleContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.TitleContent'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.TitleContent', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
        for footnote_ in self.footnote:
            footnote_.export(outfile, level, namespace_, name_='footnote', pretty_print=pretty_print)
        for footnoteRef_ in self.footnoteRef:
            footnoteRef_.export(outfile, level, namespace_, name_='footnoteRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        elif nodeName_ == 'footnote':
            obj_ = StrucDoc_TitleFootnote.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnote'):
              self.add_footnote(obj_.value)
            elif hasattr(self, 'set_footnote'):
              self.set_footnote(obj_.value)
        elif nodeName_ == 'footnoteRef':
            obj_ = StrucDoc_FootnoteRef.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'footnoteRef', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_footnoteRef'):
              self.add_footnoteRef(obj_.value)
            elif hasattr(self, 'set_footnoteRef'):
              self.set_footnoteRef(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_TitleFootnote(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, content=None, sub=None, sup=None, br=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        if content is None:
            self.content = []
        else:
            self.content = content
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        if sup is None:
            self.sup = []
        else:
            self.sup = sup
        if br is None:
            self.br = []
        else:
            self.br = br
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_TitleFootnote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_TitleFootnote.subclass:
            return StrucDoc_TitleFootnote.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_TitleFootnote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content_at(self, index, value): self.content.insert(index, value)
    def replace_content_at(self, index, value): self.content[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def get_sup(self): return self.sup
    def set_sup(self, sup): self.sup = sup
    def add_sup(self, value): self.sup.append(value)
    def insert_sup_at(self, index, value): self.sup.insert(index, value)
    def replace_sup_at(self, index, value): self.sup[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.content or
            self.sub or
            self.sup or
            self.br or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.TitleFootnote', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.TitleFootnote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.TitleFootnote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.TitleFootnote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.TitleFootnote'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.TitleFootnote', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_ in self.content:
            content_.export(outfile, level, namespace_, name_='content', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_, name_='sub', pretty_print=pretty_print)
        for sup_ in self.sup:
            sup_.export(outfile, level, namespace_, name_='sup', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = StrucDoc_TitleContent.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'content', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_content'):
              self.add_content(obj_.value)
            elif hasattr(self, 'set_content'):
              self.set_content(obj_.value)
        elif nodeName_ == 'sub':
            obj_ = StrucDoc_Sub.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'sup':
            obj_ = StrucDoc_Sup.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sup', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sup'):
              self.add_sup(obj_.value)
            elif hasattr(self, 'set_sup'):
              self.set_sup(obj_.value)
        elif nodeName_ == 'br':
            obj_ = StrucDoc_Br.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class StrucDoc_Tr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, language=None, styleCode=None, align=None, char=None, charoff=None, valign=None, th=None, td=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.language = _cast(None, language)
        self.styleCode = _cast(None, styleCode)
        self.align = _cast(None, align)
        self.char = _cast(None, char)
        self.charoff = _cast(None, charoff)
        self.valign = _cast(None, valign)
        if th is None:
            self.th = []
        else:
            self.th = th
        if td is None:
            self.td = []
        else:
            self.td = td
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StrucDoc_Tr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StrucDoc_Tr.subclass:
            return StrucDoc_Tr.subclass(*args_, **kwargs_)
        else:
            return StrucDoc_Tr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_th(self): return self.th
    def set_th(self, th): self.th = th
    def add_th(self, value): self.th.append(value)
    def insert_th_at(self, index, value): self.th.insert(index, value)
    def replace_th_at(self, index, value): self.th[index] = value
    def get_td(self): return self.td
    def set_td(self, td): self.td = td
    def add_td(self, value): self.td.append(value)
    def insert_td_at(self, index, value): self.td.insert(index, value)
    def replace_td_at(self, index, value): self.td[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_styleCode(self): return self.styleCode
    def set_styleCode(self, styleCode): self.styleCode = styleCode
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_charoff(self): return self.charoff
    def set_charoff(self, charoff): self.charoff = charoff
    def get_valign(self): return self.valign
    def set_valign(self, valign): self.valign = valign
    def hasContent_(self):
        if (
            self.th or
            self.td
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StrucDoc.Tr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StrucDoc.Tr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StrucDoc.Tr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StrucDoc.Tr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StrucDoc.Tr'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.styleCode is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            outfile.write(' styleCode=%s' % (quote_attrib(self.styleCode), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.char is not None and 'char' not in already_processed:
            already_processed.add('char')
            outfile.write(' char=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.char), input_name='char')), ))
        if self.charoff is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            outfile.write(' charoff=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.charoff), input_name='charoff')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StrucDoc.Tr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for th_ in self.th:
            th_.export(outfile, level, namespace_, name_='th', pretty_print=pretty_print)
        for td_ in self.td:
            td_.export(outfile, level, namespace_, name_='td', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('styleCode', node)
        if value is not None and 'styleCode' not in already_processed:
            already_processed.add('styleCode')
            self.styleCode = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('char', node)
        if value is not None and 'char' not in already_processed:
            already_processed.add('char')
            self.char = value
        value = find_attr_value_('charoff', node)
        if value is not None and 'charoff' not in already_processed:
            already_processed.add('charoff')
            self.charoff = value
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'th':
            obj_ = StrucDoc_Th.factory()
            obj_.build(child_)
            self.th.append(obj_)
            obj_.original_tagname_ = 'th'
        elif nodeName_ == 'td':
            obj_ = StrucDoc_Td.factory()
            obj_.build(child_)
            self.td.append(obj_)
            obj_.original_tagname_ = 'td'


class Subject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typeCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, patient=None):
        self.original_tagname_ = None
        self.typeCode = _cast(None, typeCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.patient = patient
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Subject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Subject.subclass:
            return Subject.subclass(*args_, **kwargs_)
        else:
            return Subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_patient(self): return self.patient
    def set_patient(self, patient): self.patient = patient
    def get_typeCode(self): return self.typeCode
    def set_typeCode(self, typeCode): self.typeCode = typeCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.patient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Subject', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000016GB01.Subject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000016GB01.Subject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000016GB01.Subject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000016GB01.Subject'):
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000016GB01.Subject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.patient is not None:
            self.patient.export(outfile, level, namespace_, name_='patient', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_cs(self.typeCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'patient':
            obj_ = Patient.factory()
            obj_.build(child_)
            self.patient = obj_
            obj_.original_tagname_ = 'patient'


class a(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, href=None, iiref=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.href = _cast(None, href)
        self.iiref = _cast(None, iiref)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, a)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if a.subclass:
            return a.subclass(*args_, **kwargs_)
        else:
            return a(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_iiref(self): return self.iiref
    def set_iiref(self, iiref): self.iiref = iiref
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_localURI(self, value):
        # Validate type localURI, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_localURI_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_localURI_patterns_, ))
    validate_localURI_patterns_ = [['^#.*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='a', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('a')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='a')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='a'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.iiref is not None and 'iiref' not in already_processed:
            already_processed.add('iiref')
            outfile.write(' iiref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.iiref), input_name='iiref')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='a', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
            self.validate_localURI(self.href)    # validate type localURI
        value = find_attr_value_('iiref', node)
        if value is not None and 'iiref' not in already_processed:
            already_processed.add('iiref')
            self.iiref = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class addressKeyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressKeyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressKeyType.subclass:
            return addressKeyType.subclass(*args_, **kwargs_)
        else:
            return addressKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='addressKeyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressKeyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressKeyType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='addressKeyType'):
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='addressKeyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class addressKeyType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressKeyType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressKeyType20.subclass:
            return addressKeyType20.subclass(*args_, **kwargs_)
        else:
            return addressKeyType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='addressKeyType20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressKeyType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressKeyType20')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='addressKeyType20'):
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='addressKeyType20', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class bodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, h2=None, h3=None, h4=None, h5=None, h6=None, p=None, ol=None, ul=None, table=None, a=None, pre=None, br=None):
        self.original_tagname_ = None
        if h2 is None:
            self.h2 = []
        else:
            self.h2 = h2
        if h3 is None:
            self.h3 = []
        else:
            self.h3 = h3
        if h4 is None:
            self.h4 = []
        else:
            self.h4 = h4
        if h5 is None:
            self.h5 = []
        else:
            self.h5 = h5
        if h6 is None:
            self.h6 = []
        else:
            self.h6 = h6
        if p is None:
            self.p = []
        else:
            self.p = p
        if ol is None:
            self.ol = []
        else:
            self.ol = ol
        if ul is None:
            self.ul = []
        else:
            self.ul = ul
        if table is None:
            self.table = []
        else:
            self.table = table
        if a is None:
            self.a = []
        else:
            self.a = a
        if pre is None:
            self.pre = []
        else:
            self.pre = pre
        if br is None:
            self.br = []
        else:
            self.br = br
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bodyType.subclass:
            return bodyType.subclass(*args_, **kwargs_)
        else:
            return bodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_h2(self): return self.h2
    def set_h2(self, h2): self.h2 = h2
    def add_h2(self, value): self.h2.append(value)
    def insert_h2_at(self, index, value): self.h2.insert(index, value)
    def replace_h2_at(self, index, value): self.h2[index] = value
    def get_h3(self): return self.h3
    def set_h3(self, h3): self.h3 = h3
    def add_h3(self, value): self.h3.append(value)
    def insert_h3_at(self, index, value): self.h3.insert(index, value)
    def replace_h3_at(self, index, value): self.h3[index] = value
    def get_h4(self): return self.h4
    def set_h4(self, h4): self.h4 = h4
    def add_h4(self, value): self.h4.append(value)
    def insert_h4_at(self, index, value): self.h4.insert(index, value)
    def replace_h4_at(self, index, value): self.h4[index] = value
    def get_h5(self): return self.h5
    def set_h5(self, h5): self.h5 = h5
    def add_h5(self, value): self.h5.append(value)
    def insert_h5_at(self, index, value): self.h5.insert(index, value)
    def replace_h5_at(self, index, value): self.h5[index] = value
    def get_h6(self): return self.h6
    def set_h6(self, h6): self.h6 = h6
    def add_h6(self, value): self.h6.append(value)
    def insert_h6_at(self, index, value): self.h6.insert(index, value)
    def replace_h6_at(self, index, value): self.h6[index] = value
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def add_p(self, value): self.p.append(value)
    def insert_p_at(self, index, value): self.p.insert(index, value)
    def replace_p_at(self, index, value): self.p[index] = value
    def get_ol(self): return self.ol
    def set_ol(self, ol): self.ol = ol
    def add_ol(self, value): self.ol.append(value)
    def insert_ol_at(self, index, value): self.ol.insert(index, value)
    def replace_ol_at(self, index, value): self.ol[index] = value
    def get_ul(self): return self.ul
    def set_ul(self, ul): self.ul = ul
    def add_ul(self, value): self.ul.append(value)
    def insert_ul_at(self, index, value): self.ul.insert(index, value)
    def replace_ul_at(self, index, value): self.ul[index] = value
    def get_table(self): return self.table
    def set_table(self, table): self.table = table
    def add_table(self, value): self.table.append(value)
    def insert_table_at(self, index, value): self.table.insert(index, value)
    def replace_table_at(self, index, value): self.table[index] = value
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def add_a(self, value): self.a.append(value)
    def insert_a_at(self, index, value): self.a.insert(index, value)
    def replace_a_at(self, index, value): self.a[index] = value
    def get_pre(self): return self.pre
    def set_pre(self, pre): self.pre = pre
    def add_pre(self, value): self.pre.append(value)
    def insert_pre_at(self, index, value): self.pre.insert(index, value)
    def replace_pre_at(self, index, value): self.pre[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def hasContent_(self):
        if (
            self.h2 or
            self.h3 or
            self.h4 or
            self.h5 or
            self.h6 or
            self.p or
            self.ol or
            self.ul or
            self.table or
            self.a or
            self.pre or
            self.br
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='bodyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bodyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bodyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='bodyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='bodyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bodyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for h2_ in self.h2:
            h2_.export(outfile, level, namespace_, name_='h2', pretty_print=pretty_print)
        for h3_ in self.h3:
            h3_.export(outfile, level, namespace_, name_='h3', pretty_print=pretty_print)
        for h4_ in self.h4:
            h4_.export(outfile, level, namespace_, name_='h4', pretty_print=pretty_print)
        for h5_ in self.h5:
            h5_.export(outfile, level, namespace_, name_='h5', pretty_print=pretty_print)
        for h6_ in self.h6:
            h6_.export(outfile, level, namespace_, name_='h6', pretty_print=pretty_print)
        for p_ in self.p:
            p_.export(outfile, level, namespace_, name_='p', pretty_print=pretty_print)
        for ol_ in self.ol:
            ol_.export(outfile, level, namespace_, name_='ol', pretty_print=pretty_print)
        for ul_ in self.ul:
            ul_.export(outfile, level, namespace_, name_='ul', pretty_print=pretty_print)
        for table_ in self.table:
            table_.export(outfile, level, namespace_, name_='table', pretty_print=pretty_print)
        for a_ in self.a:
            a_.export(outfile, level, namespace_, name_='a', pretty_print=pretty_print)
        for pre_ in self.pre:
            pre_.export(outfile, level, namespace_, name_='pre', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'h2':
            obj_ = h2.factory()
            obj_.build(child_)
            self.h2.append(obj_)
            obj_.original_tagname_ = 'h2'
        elif nodeName_ == 'h3':
            obj_ = h3.factory()
            obj_.build(child_)
            self.h3.append(obj_)
            obj_.original_tagname_ = 'h3'
        elif nodeName_ == 'h4':
            obj_ = h4.factory()
            obj_.build(child_)
            self.h4.append(obj_)
            obj_.original_tagname_ = 'h4'
        elif nodeName_ == 'h5':
            obj_ = h5.factory()
            obj_.build(child_)
            self.h5.append(obj_)
            obj_.original_tagname_ = 'h5'
        elif nodeName_ == 'h6':
            obj_ = h6.factory()
            obj_.build(child_)
            self.h6.append(obj_)
            obj_.original_tagname_ = 'h6'
        elif nodeName_ == 'p':
            obj_ = p.factory()
            obj_.build(child_)
            self.p.append(obj_)
            obj_.original_tagname_ = 'p'
        elif nodeName_ == 'ol':
            obj_ = ol.factory()
            obj_.build(child_)
            self.ol.append(obj_)
            obj_.original_tagname_ = 'ol'
        elif nodeName_ == 'ul':
            obj_ = ul.factory()
            obj_.build(child_)
            self.ul.append(obj_)
            obj_.original_tagname_ = 'ul'
        elif nodeName_ == 'table':
            obj_ = table.factory()
            obj_.build(child_)
            self.table.append(obj_)
            obj_.original_tagname_ = 'table'
        elif nodeName_ == 'a':
            obj_ = a.factory()
            obj_.build(child_)
            self.a.append(obj_)
            obj_.original_tagname_ = 'a'
        elif nodeName_ == 'pre':
            obj_ = pre.factory()
            obj_.build(child_)
            self.pre.append(obj_)
            obj_.original_tagname_ = 'pre'
        elif nodeName_ == 'br':
            obj_ = brType.factory()
            obj_.build(child_)
            self.br.append(obj_)
            obj_.original_tagname_ = 'br'


class brType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, brType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if brType.subclass:
            return brType.subclass(*args_, **kwargs_)
        else:
            return brType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='brType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='brType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='brType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='brType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='brType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class caption(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, caption)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if caption.subclass:
            return caption.subclass(*args_, **kwargs_)
        else:
            return caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='caption', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('caption')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='caption')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='caption'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='caption', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class descType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descType.subclass:
            return descType.subclass(*args_, **kwargs_)
        else:
            return descType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descType'):
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='descType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class descType21(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descType21.subclass:
            return descType21.subclass(*args_, **kwargs_)
        else:
            return descType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descType21', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descType21')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descType21'):
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='descType21', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class groupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qualifier=None):
        self.original_tagname_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def add_qualifier(self, value): self.qualifier.append(value)
    def insert_qualifier_at(self, index, value): self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value): self.qualifier[index] = value
    def hasContent_(self):
        if (
            self.qualifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='groupType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='groupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='groupType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='groupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for qualifier_ in self.qualifier:
            qualifier_.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            self.qualifier.append(obj_)
            obj_.original_tagname_ = 'qualifier'


class groupType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qualifier=None):
        self.original_tagname_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType22.subclass:
            return groupType22.subclass(*args_, **kwargs_)
        else:
            return groupType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def add_qualifier(self, value): self.qualifier.append(value)
    def insert_qualifier_at(self, index, value): self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value): self.qualifier[index] = value
    def hasContent_(self):
        if (
            self.qualifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='groupType22', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType22')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='groupType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='groupType22'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='groupType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for qualifier_ in self.qualifier:
            qualifier_.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            self.qualifier.append(obj_)
            obj_.original_tagname_ = 'qualifier'


class h2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, h2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if h2.subclass:
            return h2.subclass(*args_, **kwargs_)
        else:
            return h2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='h2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('h2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='h2')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='h2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='h2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class h3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, h3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if h3.subclass:
            return h3.subclass(*args_, **kwargs_)
        else:
            return h3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='h3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('h3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='h3')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='h3'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='h3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class h4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, h4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if h4.subclass:
            return h4.subclass(*args_, **kwargs_)
        else:
            return h4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='h4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('h4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='h4')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='h4'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='h4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class h5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, h5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if h5.subclass:
            return h5.subclass(*args_, **kwargs_)
        else:
            return h5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='h5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('h5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='h5')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='h5'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='h5', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class h6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, h6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if h6.subclass:
            return h6.subclass(*args_, **kwargs_)
        else:
            return h6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='h6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('h6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='h6')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='h6'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='h6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class headType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, headType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if headType.subclass:
            return headType.subclass(*args_, **kwargs_)
        else:
            return headType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='headType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('headType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='headType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='headType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='headType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='headType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class htmlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, head=None, body=None):
        self.original_tagname_ = None
        self.head = head
        self.body = body
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, htmlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if htmlType.subclass:
            return htmlType.subclass(*args_, **kwargs_)
        else:
            return htmlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_head(self): return self.head
    def set_head(self, head): self.head = head
    def get_body(self): return self.body
    def set_body(self, body): self.body = body
    def hasContent_(self):
        if (
            self.head is not None or
            self.body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='htmlType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('htmlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='htmlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='htmlType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='htmlType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='htmlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            self.head.export(outfile, level, namespace_, name_='head', pretty_print=pretty_print)
        if self.body is not None:
            self.body.export(outfile, level, namespace_, name_='body', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'head':
            obj_ = headType.factory()
            obj_.build(child_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'body':
            obj_ = bodyType.factory()
            obj_.build(child_)
            self.body = obj_
            obj_.original_tagname_ = 'body'


class htmlType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, head=None, body=None):
        self.original_tagname_ = None
        self.head = head
        self.body = body
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, htmlType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if htmlType2.subclass:
            return htmlType2.subclass(*args_, **kwargs_)
        else:
            return htmlType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_head(self): return self.head
    def set_head(self, head): self.head = head
    def get_body(self): return self.body
    def set_body(self, body): self.body = body
    def hasContent_(self):
        if (
            self.head is not None or
            self.body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='htmlType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('htmlType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='htmlType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='htmlType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='htmlType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='htmlType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            self.head.export(outfile, level, namespace_, name_='head', pretty_print=pretty_print)
        if self.body is not None:
            self.body.export(outfile, level, namespace_, name_='body', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'head':
            obj_ = headType.factory()
            obj_.build(child_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'body':
            obj_ = bodyType.factory()
            obj_.build(child_)
            self.body = obj_
            obj_.original_tagname_ = 'body'


class li(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, a=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.a = a
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, li)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if li.subclass:
            return li.subclass(*args_, **kwargs_)
        else:
            return li(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.a is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='li', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('li')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='li')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='li', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='li'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='li', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.a is not None:
            self.a.export(outfile, level, namespace_, name_='a', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'a':
            obj_ = a.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'a', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_a'):
              self.add_a(obj_.value)
            elif hasattr(self, 'set_a'):
              self.set_a(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class ol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, li=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        if li is None:
            self.li = []
        else:
            self.li = li
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ol.subclass:
            return ol.subclass(*args_, **kwargs_)
        else:
            return ol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_li(self): return self.li
    def set_li(self, li): self.li = li
    def add_li(self, value): self.li.append(value)
    def insert_li_at(self, index, value): self.li.insert(index, value)
    def replace_li_at(self, index, value): self.li[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.li
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ol'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for li_ in self.li:
            li_.export(outfile, level, namespace_, name_='li', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'li':
            obj_ = li.factory()
            obj_.build(child_)
            self.li.append(obj_)
            obj_.original_tagname_ = 'li'


class p(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, p_member=None, ol=None, ul=None, table=None, a=None, pre=None, br=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        if p_member is None:
            self.p = []
        else:
            self.p = p_member
        if ol is None:
            self.ol = []
        else:
            self.ol = ol
        if ul is None:
            self.ul = []
        else:
            self.ul = ul
        if table is None:
            self.table = []
        else:
            self.table = table
        if a is None:
            self.a = []
        else:
            self.a = a
        if pre is None:
            self.pre = []
        else:
            self.pre = pre
        if br is None:
            self.br = []
        else:
            self.br = br
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, p)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if p.subclass:
            return p.subclass(*args_, **kwargs_)
        else:
            return p(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def add_p(self, value): self.p.append(value)
    def insert_p_at(self, index, value): self.p.insert(index, value)
    def replace_p_at(self, index, value): self.p[index] = value
    def get_ol(self): return self.ol
    def set_ol(self, ol): self.ol = ol
    def add_ol(self, value): self.ol.append(value)
    def insert_ol_at(self, index, value): self.ol.insert(index, value)
    def replace_ol_at(self, index, value): self.ol[index] = value
    def get_ul(self): return self.ul
    def set_ul(self, ul): self.ul = ul
    def add_ul(self, value): self.ul.append(value)
    def insert_ul_at(self, index, value): self.ul.insert(index, value)
    def replace_ul_at(self, index, value): self.ul[index] = value
    def get_table(self): return self.table
    def set_table(self, table): self.table = table
    def add_table(self, value): self.table.append(value)
    def insert_table_at(self, index, value): self.table.insert(index, value)
    def replace_table_at(self, index, value): self.table[index] = value
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def add_a(self, value): self.a.append(value)
    def insert_a_at(self, index, value): self.a.insert(index, value)
    def replace_a_at(self, index, value): self.a[index] = value
    def get_pre(self): return self.pre
    def set_pre(self, pre): self.pre = pre
    def add_pre(self, value): self.pre.append(value)
    def insert_pre_at(self, index, value): self.pre.insert(index, value)
    def replace_pre_at(self, index, value): self.pre[index] = value
    def get_br(self): return self.br
    def set_br(self, br): self.br = br
    def add_br(self, value): self.br.append(value)
    def insert_br_at(self, index, value): self.br.insert(index, value)
    def replace_br_at(self, index, value): self.br[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.p or
            self.ol or
            self.ul or
            self.table or
            self.a or
            self.pre or
            self.br or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='p', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('p')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='p')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='p', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='p'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='p', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for p_ in self.p:
            p_.export(outfile, level, namespace_, name_='p', pretty_print=pretty_print)
        for ol_ in self.ol:
            ol_.export(outfile, level, namespace_, name_='ol', pretty_print=pretty_print)
        for ul_ in self.ul:
            ul_.export(outfile, level, namespace_, name_='ul', pretty_print=pretty_print)
        for table_ in self.table:
            table_.export(outfile, level, namespace_, name_='table', pretty_print=pretty_print)
        for a_ in self.a:
            a_.export(outfile, level, namespace_, name_='a', pretty_print=pretty_print)
        for pre_ in self.pre:
            pre_.export(outfile, level, namespace_, name_='pre', pretty_print=pretty_print)
        for br_ in self.br:
            br_.export(outfile, level, namespace_, name_='br', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'p':
            obj_ = p.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'p', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_p'):
              self.add_p(obj_.value)
            elif hasattr(self, 'set_p'):
              self.set_p(obj_.value)
        elif nodeName_ == 'ol':
            obj_ = ol.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ol', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ol'):
              self.add_ol(obj_.value)
            elif hasattr(self, 'set_ol'):
              self.set_ol(obj_.value)
        elif nodeName_ == 'ul':
            obj_ = ul.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ul', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ul'):
              self.add_ul(obj_.value)
            elif hasattr(self, 'set_ul'):
              self.set_ul(obj_.value)
        elif nodeName_ == 'table':
            obj_ = table.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
              self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
              self.set_table(obj_.value)
        elif nodeName_ == 'a':
            obj_ = a.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'a', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_a'):
              self.add_a(obj_.value)
            elif hasattr(self, 'set_a'):
              self.set_a(obj_.value)
        elif nodeName_ == 'pre':
            obj_ = pre.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'pre', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_pre'):
              self.add_pre(obj_.value)
            elif hasattr(self, 'set_pre'):
              self.set_pre(obj_.value)
        elif nodeName_ == 'br':
            obj_ = brType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'br', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_br'):
              self.add_br(obj_.value)
            elif hasattr(self, 'set_br'):
              self.set_br(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class pre(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pre)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pre.subclass:
            return pre.subclass(*args_, **kwargs_)
        else:
            return pre(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pre', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pre')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pre')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pre'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pre', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class table(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, summary=None, id=None, class_=None, caption=None, thead=None, tfoot=None, tbody=None, tr=None):
        self.original_tagname_ = None
        self.summary = _cast(None, summary)
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.caption = caption
        self.thead = thead
        self.tfoot = tfoot
        if tbody is None:
            self.tbody = []
        else:
            self.tbody = tbody
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, table)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if table.subclass:
            return table.subclass(*args_, **kwargs_)
        else:
            return table(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_thead(self): return self.thead
    def set_thead(self, thead): self.thead = thead
    def get_tfoot(self): return self.tfoot
    def set_tfoot(self, tfoot): self.tfoot = tfoot
    def get_tbody(self): return self.tbody
    def set_tbody(self, tbody): self.tbody = tbody
    def add_tbody(self, value): self.tbody.append(value)
    def insert_tbody_at(self, index, value): self.tbody.insert(index, value)
    def replace_tbody_at(self, index, value): self.tbody[index] = value
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def get_summary(self): return self.summary
    def set_summary(self, summary): self.summary = summary
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.caption is not None or
            self.thead is not None or
            self.tfoot is not None or
            self.tbody or
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='table', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('table')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='table')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='table', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='table'):
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            outfile.write(' summary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.summary), input_name='summary')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='table', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            self.caption.export(outfile, level, namespace_, name_='caption', pretty_print=pretty_print)
        if self.thead is not None:
            self.thead.export(outfile, level, namespace_, name_='thead', pretty_print=pretty_print)
        if self.tfoot is not None:
            self.tfoot.export(outfile, level, namespace_, name_='tfoot', pretty_print=pretty_print)
        for tbody_ in self.tbody:
            tbody_.export(outfile, level, namespace_, name_='tbody', pretty_print=pretty_print)
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('summary', node)
        if value is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            self.summary = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'caption':
            obj_ = caption.factory()
            obj_.build(child_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'thead':
            obj_ = thead.factory()
            obj_.build(child_)
            self.thead = obj_
            obj_.original_tagname_ = 'thead'
        elif nodeName_ == 'tfoot':
            obj_ = tfoot.factory()
            obj_.build(child_)
            self.tfoot = obj_
            obj_.original_tagname_ = 'tfoot'
        elif nodeName_ == 'tbody':
            obj_ = tbody.factory()
            obj_.build(child_)
            self.tbody.append(obj_)
            obj_.original_tagname_ = 'tbody'
        elif nodeName_ == 'tr':
            obj_ = tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class tbody(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, tr=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tbody)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tbody.subclass:
            return tbody.subclass(*args_, **kwargs_)
        else:
            return tbody(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tbody', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tbody')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tbody')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tbody', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tbody'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tbody', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tr':
            obj_ = tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class td(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, rowspan=None, colspan=None, abbr=None, headers=None, li=None, ol=None, ul=None, a=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.rowspan = _cast(None, rowspan)
        self.colspan = _cast(None, colspan)
        self.abbr = _cast(None, abbr)
        self.headers = _cast(None, headers)
        if li is None:
            self.li = []
        else:
            self.li = li
        if ol is None:
            self.ol = []
        else:
            self.ol = ol
        if ul is None:
            self.ul = []
        else:
            self.ul = ul
        if a is None:
            self.a = []
        else:
            self.a = a
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, td)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if td.subclass:
            return td.subclass(*args_, **kwargs_)
        else:
            return td(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_li(self): return self.li
    def set_li(self, li): self.li = li
    def add_li(self, value): self.li.append(value)
    def insert_li_at(self, index, value): self.li.insert(index, value)
    def replace_li_at(self, index, value): self.li[index] = value
    def get_ol(self): return self.ol
    def set_ol(self, ol): self.ol = ol
    def add_ol(self, value): self.ol.append(value)
    def insert_ol_at(self, index, value): self.ol.insert(index, value)
    def replace_ol_at(self, index, value): self.ol[index] = value
    def get_ul(self): return self.ul
    def set_ul(self, ul): self.ul = ul
    def add_ul(self, value): self.ul.append(value)
    def insert_ul_at(self, index, value): self.ul.insert(index, value)
    def replace_ul_at(self, index, value): self.ul[index] = value
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def add_a(self, value): self.a.append(value)
    def insert_a_at(self, index, value): self.a.insert(index, value)
    def replace_a_at(self, index, value): self.a[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_rowspan(self): return self.rowspan
    def set_rowspan(self, rowspan): self.rowspan = rowspan
    def get_colspan(self): return self.colspan
    def set_colspan(self, colspan): self.colspan = colspan
    def get_abbr(self): return self.abbr
    def set_abbr(self, abbr): self.abbr = abbr
    def get_headers(self): return self.headers
    def set_headers(self, headers): self.headers = headers
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.li or
            self.ol or
            self.ul or
            self.a or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='td', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('td')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='td')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='td', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='td'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.rowspan is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rowspan), input_name='rowspan')), ))
        if self.colspan is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.colspan), input_name='colspan')), ))
        if self.abbr is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            outfile.write(' abbr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abbr), input_name='abbr')), ))
        if self.headers is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            outfile.write(' headers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.headers), input_name='headers')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='td', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for li_ in self.li:
            li_.export(outfile, level, namespace_, name_='li', pretty_print=pretty_print)
        for ol_ in self.ol:
            ol_.export(outfile, level, namespace_, name_='ol', pretty_print=pretty_print)
        for ul_ in self.ul:
            ul_.export(outfile, level, namespace_, name_='ul', pretty_print=pretty_print)
        for a_ in self.a:
            a_.export(outfile, level, namespace_, name_='a', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = value
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = value
        value = find_attr_value_('abbr', node)
        if value is not None and 'abbr' not in already_processed:
            already_processed.add('abbr')
            self.abbr = value
        value = find_attr_value_('headers', node)
        if value is not None and 'headers' not in already_processed:
            already_processed.add('headers')
            self.headers = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'li':
            obj_ = li.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'li', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_li'):
              self.add_li(obj_.value)
            elif hasattr(self, 'set_li'):
              self.set_li(obj_.value)
        elif nodeName_ == 'ol':
            obj_ = ol.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ol', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ol'):
              self.add_ol(obj_.value)
            elif hasattr(self, 'set_ol'):
              self.set_ol(obj_.value)
        elif nodeName_ == 'ul':
            obj_ = ul.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ul', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ul'):
              self.add_ul(obj_.value)
            elif hasattr(self, 'set_ul'):
              self.set_ul(obj_.value)
        elif nodeName_ == 'a':
            obj_ = a.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'a', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_a'):
              self.add_a(obj_.value)
            elif hasattr(self, 'set_a'):
              self.set_a(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)


class tfoot(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tr=None):
        self.original_tagname_ = None
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tfoot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tfoot.subclass:
            return tfoot.subclass(*args_, **kwargs_)
        else:
            return tfoot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tfoot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tfoot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tfoot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tfoot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tfoot'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tfoot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tr':
            obj_ = tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class th(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, th)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if th.subclass:
            return th.subclass(*args_, **kwargs_)
        else:
            return th(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='th', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('th')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='th')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='th'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='th', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class thead(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, tr=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        if tr is None:
            self.tr = []
        else:
            self.tr = tr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, thead)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if thead.subclass:
            return thead.subclass(*args_, **kwargs_)
        else:
            return thead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tr(self): return self.tr
    def set_tr(self, tr): self.tr = tr
    def add_tr(self, value): self.tr.append(value)
    def insert_tr_at(self, index, value): self.tr.insert(index, value)
    def replace_tr_at(self, index, value): self.tr[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.tr
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='thead', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('thead')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='thead')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='thead', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='thead'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='thead', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tr_ in self.tr:
            tr_.export(outfile, level, namespace_, name_='tr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tr':
            obj_ = tr.factory()
            obj_.build(child_)
            self.tr.append(obj_)
            obj_.original_tagname_ = 'tr'


class tr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, th=None, td=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        if th is None:
            self.th = []
        else:
            self.th = th
        if td is None:
            self.td = []
        else:
            self.td = td
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tr.subclass:
            return tr.subclass(*args_, **kwargs_)
        else:
            return tr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_th(self): return self.th
    def set_th(self, th): self.th = th
    def add_th(self, value): self.th.append(value)
    def insert_th_at(self, index, value): self.th.insert(index, value)
    def replace_th_at(self, index, value): self.th[index] = value
    def get_td(self): return self.td
    def set_td(self, td): self.td = td
    def add_td(self, value): self.td.append(value)
    def insert_td_at(self, index, value): self.td.insert(index, value)
    def replace_td_at(self, index, value): self.td[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.th or
            self.td
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tr'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for th_ in self.th:
            th_.export(outfile, level, namespace_, name_='th', pretty_print=pretty_print)
        for td_ in self.td:
            td_.export(outfile, level, namespace_, name_='td', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'th':
            obj_ = th.factory()
            obj_.build(child_)
            self.th.append(obj_)
            obj_.original_tagname_ = 'th'
        elif nodeName_ == 'td':
            obj_ = td.factory()
            obj_.build(child_)
            self.td.append(obj_)
            obj_.original_tagname_ = 'td'


class ul(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, class_=None, li=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.class_ = _cast(None, class_)
        if li is None:
            self.li = []
        else:
            self.li = li
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ul)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ul.subclass:
            return ul.subclass(*args_, **kwargs_)
        else:
            return ul(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_li(self): return self.li
    def set_li(self, li): self.li = li
    def add_li(self, value): self.li.append(value)
    def insert_li_at(self, index, value): self.li.insert(index, value)
    def replace_li_at(self, index, value): self.li[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.li
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ul', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ul')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ul')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ul', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ul'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ul', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for li_ in self.li:
            li_.export(outfile, level, namespace_, name_='li', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'li':
            obj_ = li.factory()
            obj_.build(child_)
            self.li.append(obj_)
            obj_.original_tagname_ = 'li'


class Person_DateOfBirth(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, value=None, semanticsText=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.value = value
        self.semanticsText = semanticsText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person_DateOfBirth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person_DateOfBirth.subclass:
            return Person_DateOfBirth.subclass(*args_, **kwargs_)
        else:
            return Person_DateOfBirth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_semanticsText(self): return self.semanticsText
    def set_semanticsText(self, semanticsText): self.semanticsText = semanticsText
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.value is not None or
            self.semanticsText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000001GB01.Person.DateOfBirth', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000001GB01.Person.DateOfBirth')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000001GB01.Person.DateOfBirth')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000001GB01.Person.DateOfBirth', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000001GB01.Person.DateOfBirth'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000001GB01.Person.DateOfBirth', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.semanticsText is not None:
            self.semanticsText.export(outfile, level, namespace_, name_='semanticsText', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'value':
            obj_ = TS_NHS_TimestampType1.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'semanticsText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semanticsText = obj_
            obj_.original_tagname_ = 'semanticsText'


class Person_NHSNumber(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, value=None, semanticsText=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.value = value
        self.semanticsText = semanticsText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person_NHSNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person_NHSNumber.subclass:
            return Person_NHSNumber.subclass(*args_, **kwargs_)
        else:
            return Person_NHSNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_semanticsText(self): return self.semanticsText
    def set_semanticsText(self, semanticsText): self.semanticsText = semanticsText
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.value is not None or
            self.semanticsText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000001GB01.Person.NHSNumber', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000001GB01.Person.NHSNumber')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000001GB01.Person.NHSNumber')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000001GB01.Person.NHSNumber', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000001GB01.Person.NHSNumber'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000001GB01.Person.NHSNumber', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.semanticsText is not None:
            self.semanticsText.export(outfile, level, namespace_, name_='semanticsText', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'value':
            obj_ = II_NHS_IdentifierType1.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'semanticsText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semanticsText = obj_
            obj_.original_tagname_ = 'semanticsText'


class Person_Name(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, value=None, semanticsText=None):
        self.original_tagname_ = None
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.value = value
        self.semanticsText = semanticsText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person_Name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person_Name.subclass:
            return Person_Name.subclass(*args_, **kwargs_)
        else:
            return Person_Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_semanticsText(self): return self.semanticsText
    def set_semanticsText(self, semanticsText): self.semanticsText = semanticsText
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.value is not None or
            self.semanticsText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUPA_MT000001GB01.Person.Name', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUPA_MT000001GB01.Person.Name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUPA_MT000001GB01.Person.Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUPA_MT000001GB01.Person.Name', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUPA_MT000001GB01.Person.Name'):
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QUPA_MT000001GB01.Person.Name', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.semanticsText is not None:
            self.semanticsText.export(outfile, level, namespace_, name_='semanticsText', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'value':
            obj_ = PN_NHS_PersonNameType1.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'semanticsText':
            class_obj_ = self.get_class_obj_(child_, ST)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.semanticsText = obj_
            obj_.original_tagname_ = 'semanticsText'


class additionalLocatorType17(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(additionalLocatorType17, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, additionalLocatorType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if additionalLocatorType17.subclass:
            return additionalLocatorType17.subclass(*args_, **kwargs_)
        else:
            return additionalLocatorType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(additionalLocatorType17, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='additionalLocatorType17', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('additionalLocatorType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='additionalLocatorType17')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='additionalLocatorType17'):
        super(additionalLocatorType17, self).exportAttributes(outfile, level, already_processed, namespace_, name_='additionalLocatorType17')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='additionalLocatorType17', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(additionalLocatorType17, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class carrierType20(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(carrierType20, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, carrierType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if carrierType20.subclass:
            return carrierType20.subclass(*args_, **kwargs_)
        else:
            return carrierType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(carrierType20, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='carrierType20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('carrierType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='carrierType20')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='carrierType20'):
        super(carrierType20, self).exportAttributes(outfile, level, already_processed, namespace_, name_='carrierType20')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='carrierType20', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(carrierType20, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class censusTractType21(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(censusTractType21, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, censusTractType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if censusTractType21.subclass:
            return censusTractType21.subclass(*args_, **kwargs_)
        else:
            return censusTractType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(censusTractType21, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='censusTractType21', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('censusTractType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='censusTractType21')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='censusTractType21'):
        super(censusTractType21, self).exportAttributes(outfile, level, already_processed, namespace_, name_='censusTractType21')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='censusTractType21', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(censusTractType21, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class cityType8(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(cityType8, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cityType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cityType8.subclass:
            return cityType8.subclass(*args_, **kwargs_)
        else:
            return cityType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(cityType8, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cityType8', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cityType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cityType8')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cityType8'):
        super(cityType8, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cityType8')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cityType8', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(cityType8, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class countyType7(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(countyType7, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, countyType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if countyType7.subclass:
            return countyType7.subclass(*args_, **kwargs_)
        else:
            return countyType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(countyType7, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='countyType7', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('countyType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='countyType7')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='countyType7'):
        super(countyType7, self).exportAttributes(outfile, level, already_processed, namespace_, name_='countyType7')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='countyType7', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(countyType7, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class delimiterType5(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(delimiterType5, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delimiterType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delimiterType5.subclass:
            return delimiterType5.subclass(*args_, **kwargs_)
        else:
            return delimiterType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(delimiterType5, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='delimiterType5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('delimiterType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='delimiterType5')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='delimiterType5'):
        super(delimiterType5, self).exportAttributes(outfile, level, already_processed, namespace_, name_='delimiterType5')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='delimiterType5', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(delimiterType5, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class directionType13(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(directionType13, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, directionType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if directionType13.subclass:
            return directionType13.subclass(*args_, **kwargs_)
        else:
            return directionType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(directionType13, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='directionType13', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('directionType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='directionType13')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='directionType13'):
        super(directionType13, self).exportAttributes(outfile, level, already_processed, namespace_, name_='directionType13')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='directionType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(directionType13, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class houseNumberNumericType12(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(houseNumberNumericType12, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, houseNumberNumericType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if houseNumberNumericType12.subclass:
            return houseNumberNumericType12.subclass(*args_, **kwargs_)
        else:
            return houseNumberNumericType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(houseNumberNumericType12, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='houseNumberNumericType12', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('houseNumberNumericType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberNumericType12')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='houseNumberNumericType12'):
        super(houseNumberNumericType12, self).exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberNumericType12')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='houseNumberNumericType12', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(houseNumberNumericType12, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class houseNumberType11(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(houseNumberType11, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, houseNumberType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if houseNumberType11.subclass:
            return houseNumberType11.subclass(*args_, **kwargs_)
        else:
            return houseNumberType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(houseNumberType11, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='houseNumberType11', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('houseNumberType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberType11')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='houseNumberType11'):
        super(houseNumberType11, self).exportAttributes(outfile, level, already_processed, namespace_, name_='houseNumberType11')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='houseNumberType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(houseNumberType11, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class postalCodeType9(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(postalCodeType9, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, postalCodeType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if postalCodeType9.subclass:
            return postalCodeType9.subclass(*args_, **kwargs_)
        else:
            return postalCodeType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(postalCodeType9, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='postalCodeType9', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('postalCodeType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postalCodeType9')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='postalCodeType9'):
        super(postalCodeType9, self).exportAttributes(outfile, level, already_processed, namespace_, name_='postalCodeType9')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='postalCodeType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(postalCodeType9, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class stateType6(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(stateType6, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stateType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stateType6.subclass:
            return stateType6.subclass(*args_, **kwargs_)
        else:
            return stateType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stateType6, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='stateType6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stateType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stateType6')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stateType6'):
        super(stateType6, self).exportAttributes(outfile, level, already_processed, namespace_, name_='stateType6')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='stateType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(stateType6, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetAddressLineType10(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetAddressLineType10, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetAddressLineType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetAddressLineType10.subclass:
            return streetAddressLineType10.subclass(*args_, **kwargs_)
        else:
            return streetAddressLineType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetAddressLineType10, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetAddressLineType10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetAddressLineType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressLineType10')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetAddressLineType10'):
        super(streetAddressLineType10, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetAddressLineType10')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetAddressLineType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetAddressLineType10, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameBaseType15(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameBaseType15, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameBaseType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameBaseType15.subclass:
            return streetNameBaseType15.subclass(*args_, **kwargs_)
        else:
            return streetNameBaseType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameBaseType15, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameBaseType15', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameBaseType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameBaseType15')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameBaseType15'):
        super(streetNameBaseType15, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameBaseType15')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameBaseType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameBaseType15, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameType14(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameType14, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameType14.subclass:
            return streetNameType14.subclass(*args_, **kwargs_)
        else:
            return streetNameType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameType14, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameType14', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType14')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameType14'):
        super(streetNameType14, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType14')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameType14', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameType14, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameType3(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameType3, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameType3.subclass:
            return streetNameType3.subclass(*args_, **kwargs_)
        else:
            return streetNameType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType3')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameType3'):
        super(streetNameType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameType3')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class streetNameTypeType16(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(streetNameTypeType16, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streetNameTypeType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streetNameTypeType16.subclass:
            return streetNameTypeType16.subclass(*args_, **kwargs_)
        else:
            return streetNameTypeType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(streetNameTypeType16, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='streetNameTypeType16', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streetNameTypeType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameTypeType16')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='streetNameTypeType16'):
        super(streetNameTypeType16, self).exportAttributes(outfile, level, already_processed, namespace_, name_='streetNameTypeType16')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='streetNameTypeType16', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(streetNameTypeType16, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class unitIDType18(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(unitIDType18, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitIDType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitIDType18.subclass:
            return unitIDType18.subclass(*args_, **kwargs_)
        else:
            return unitIDType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unitIDType18, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unitIDType18', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitIDType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitIDType18')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unitIDType18'):
        super(unitIDType18, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unitIDType18')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unitIDType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(unitIDType18, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class unitTypeType19(ADXP):
    subclass = None
    superclass = ADXP
    def __init__(self, nullFlavor=None, updateMode=None, representation='TXT', mediaType='text/plain', language=None, compression=None, integrityCheck=None, integrityCheckAlgorithm='SHA-1', reference=None, thumbnail=None, anytypeobjs_=None, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(unitTypeType19, self).__init__(nullFlavor, updateMode, representation, mediaType, language, compression, integrityCheck, integrityCheckAlgorithm, reference, thumbnail, anytypeobjs_, partType, valueOf_, mixedclass_, content_, )
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unitTypeType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unitTypeType19.subclass:
            return unitTypeType19.subclass(*args_, **kwargs_)
        else:
            return unitTypeType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unitTypeType19, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='unitTypeType19', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unitTypeType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitTypeType19')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='unitTypeType19'):
        super(unitTypeType19, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unitTypeType19')
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='unitTypeType19', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
        super(unitTypeType19, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class codeType1(CV_NHS_CodedValueType1):
    subclass = None
    superclass = CV_NHS_CodedValueType1
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(codeType1, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codeType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codeType1.subclass:
            return codeType1.subclass(*args_, **kwargs_)
        else:
            return codeType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(codeType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codeType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codeType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codeType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codeType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codeType1'):
        super(codeType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='codeType1')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
    def exportChildren(self, outfile, level, namespace_='', name_='codeType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        super(codeType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class valueType2(CV_NHS_CodedValueType1):
    subclass = None
    superclass = CV_NHS_CodedValueType1
    def __init__(self, nullFlavor=None, updateMode=None, code=None, codeSystem=None, codeSystemName=None, codeSystemVersion=None, displayName=None, originalText=None, qualifier=None, group=None, translation=None):
        self.original_tagname_ = None
        super(valueType2, self).__init__(nullFlavor, updateMode, code, codeSystem, codeSystemName, codeSystemVersion, displayName, originalText, qualifier, group, translation, )
        self.code = _cast(None, code)
        self.codeSystem = _cast(None, codeSystem)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueType2.subclass:
            return valueType2.subclass(*args_, **kwargs_)
        else:
            return valueType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_codeSystem(self): return self.codeSystem
    def set_codeSystem(self, codeSystem): self.codeSystem = codeSystem
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_uid(self, value):
        # Validate type uid, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(valueType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='valueType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valueType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='valueType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='valueType2'):
        super(valueType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='valueType2')
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.codeSystem is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            outfile.write(' codeSystem=%s' % (quote_attrib(self.codeSystem), ))
    def exportChildren(self, outfile, level, namespace_='', name_='valueType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
            self.validate_cs(self.code)    # validate type cs
        value = find_attr_value_('codeSystem', node)
        if value is not None and 'codeSystem' not in already_processed:
            already_processed.add('codeSystem')
            self.codeSystem = value
            self.validate_uid(self.codeSystem)    # validate type uid
        super(valueType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


class Component(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typeCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, validIdentifier=None):
        self.original_tagname_ = None
        self.typeCode = _cast(None, typeCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.validIdentifier = validIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Component)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Component.subclass:
            return Component.subclass(*args_, **kwargs_)
        else:
            return Component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_validIdentifier(self): return self.validIdentifier
    def set_validIdentifier(self, validIdentifier): self.validIdentifier = validIdentifier
    def get_typeCode(self): return self.typeCode
    def set_typeCode(self, typeCode): self.typeCode = typeCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.validIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000013GB01.Component', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000013GB01.Component')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000013GB01.Component')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000013GB01.Component', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000013GB01.Component'):
        if self.typeCode is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            outfile.write(' typeCode=%s' % (quote_attrib(self.typeCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000013GB01.Component', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.validIdentifier is not None:
            self.validIdentifier.export(outfile, level, namespace_, name_='validIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeCode', node)
        if value is not None and 'typeCode' not in already_processed:
            already_processed.add('typeCode')
            self.typeCode = value
            self.validate_cs(self.typeCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'validIdentifier':
            obj_ = ValidIdentifier.factory()
            obj_.build(child_)
            self.validIdentifier = obj_
            obj_.original_tagname_ = 'validIdentifier'


class ValidIdentifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classCode=None, moodCode=None, nullFlavor=None, updateMode=None, realmCode=None, typeId=None, templateId=None, code=None, value=None, subject=None):
        self.original_tagname_ = None
        self.classCode = _cast(None, classCode)
        self.moodCode = _cast(None, moodCode)
        self.nullFlavor = _cast(None, nullFlavor)
        self.updateMode = _cast(None, updateMode)
        if realmCode is None:
            self.realmCode = []
        else:
            self.realmCode = realmCode
        self.typeId = typeId
        if templateId is None:
            self.templateId = []
        else:
            self.templateId = templateId
        self.code = code
        self.value = value
        self.subject = subject
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidIdentifier.subclass:
            return ValidIdentifier.subclass(*args_, **kwargs_)
        else:
            return ValidIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_realmCode(self): return self.realmCode
    def set_realmCode(self, realmCode): self.realmCode = realmCode
    def add_realmCode(self, value): self.realmCode.append(value)
    def insert_realmCode_at(self, index, value): self.realmCode.insert(index, value)
    def replace_realmCode_at(self, index, value): self.realmCode[index] = value
    def get_typeId(self): return self.typeId
    def set_typeId(self, typeId): self.typeId = typeId
    def get_templateId(self): return self.templateId
    def set_templateId(self, templateId): self.templateId = templateId
    def add_templateId(self, value): self.templateId.append(value)
    def insert_templateId_at(self, index, value): self.templateId.insert(index, value)
    def replace_templateId_at(self, index, value): self.templateId[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def get_classCode(self): return self.classCode
    def set_classCode(self, classCode): self.classCode = classCode
    def get_moodCode(self): return self.moodCode
    def set_moodCode(self, moodCode): self.moodCode = moodCode
    def get_nullFlavor(self): return self.nullFlavor
    def set_nullFlavor(self, nullFlavor): self.nullFlavor = nullFlavor
    def get_updateMode(self): return self.updateMode
    def set_updateMode(self, updateMode): self.updateMode = updateMode
    def validate_cs(self, value):
        # Validate type cs, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_patterns_, ))
    validate_cs_patterns_ = [['^[^\\s]*$']]
    def validate_NullFlavor(self, value):
        # Validate type NullFlavor, a restriction on None.
        pass
    def validate_cs_UpdateMode(self, value):
        # Validate type cs_UpdateMode, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['added', 'altered', 'removed', 'unchanged']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_UpdateMode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_UpdateMode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_UpdateMode_patterns_, ))
    validate_cs_UpdateMode_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            self.realmCode or
            self.typeId is not None or
            self.templateId or
            self.code is not None or
            self.value is not None or
            self.subject is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMT_MT000013GB01.ValidIdentifier', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMT_MT000013GB01.ValidIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMT_MT000013GB01.ValidIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMT_MT000013GB01.ValidIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMT_MT000013GB01.ValidIdentifier'):
        if self.classCode is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            outfile.write(' classCode=%s' % (quote_attrib(self.classCode), ))
        if self.moodCode is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            outfile.write(' moodCode=%s' % (quote_attrib(self.moodCode), ))
        if self.nullFlavor is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            outfile.write(' nullFlavor=%s' % (quote_attrib(self.nullFlavor), ))
        if self.updateMode is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            outfile.write(' updateMode=%s' % (quote_attrib(self.updateMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COMT_MT000013GB01.ValidIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for realmCode_ in self.realmCode:
            realmCode_.export(outfile, level, namespace_, name_='realmCode', pretty_print=pretty_print)
        if self.typeId is not None:
            self.typeId.export(outfile, level, namespace_, name_='typeId', pretty_print=pretty_print)
        for templateId_ in self.templateId:
            templateId_.export(outfile, level, namespace_, name_='templateId', pretty_print=pretty_print)
        if self.code is not None:
            self.code.export(outfile, level, namespace_, name_='code', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.subject is not None:
            self.subject.export(outfile, level, namespace_, name_='subject', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classCode', node)
        if value is not None and 'classCode' not in already_processed:
            already_processed.add('classCode')
            self.classCode = value
            self.validate_cs(self.classCode)    # validate type cs
        value = find_attr_value_('moodCode', node)
        if value is not None and 'moodCode' not in already_processed:
            already_processed.add('moodCode')
            self.moodCode = value
            self.validate_cs(self.moodCode)    # validate type cs
        value = find_attr_value_('nullFlavor', node)
        if value is not None and 'nullFlavor' not in already_processed:
            already_processed.add('nullFlavor')
            self.nullFlavor = value
            self.validate_NullFlavor(self.nullFlavor)    # validate type NullFlavor
        value = find_attr_value_('updateMode', node)
        if value is not None and 'updateMode' not in already_processed:
            already_processed.add('updateMode')
            self.updateMode = value
            self.validate_cs_UpdateMode(self.updateMode)    # validate type cs_UpdateMode
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'realmCode':
            obj_ = CS.factory()
            obj_.build(child_)
            self.realmCode.append(obj_)
            obj_.original_tagname_ = 'realmCode'
        elif nodeName_ == 'typeId':
            obj_ = II.factory()
            obj_.build(child_)
            self.typeId = obj_
            obj_.original_tagname_ = 'typeId'
        elif nodeName_ == 'templateId':
            obj_ = II.factory()
            obj_.build(child_)
            self.templateId.append(obj_)
            obj_.original_tagname_ = 'templateId'
        elif nodeName_ == 'code':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.code = obj_
            obj_.original_tagname_ = 'code'
        elif nodeName_ == 'value':
            obj_ = valueType.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'subject':
            obj_ = Subject.factory()
            obj_.build(child_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'


class addressKeyType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressKeyType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressKeyType22.subclass:
            return addressKeyType22.subclass(*args_, **kwargs_)
        else:
            return addressKeyType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='addressKeyType22', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressKeyType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressKeyType22')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='addressKeyType22'):
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='addressKeyType22', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class descType23(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, partType=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.partType = _cast(None, partType)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descType23.subclass:
            return descType23.subclass(*args_, **kwargs_)
        else:
            return descType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_partType(self): return self.partType
    def set_partType(self, partType): self.partType = partType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cs_AddressPartType(self, value):
        # Validate type cs_AddressPartType, a restriction on cs.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEL', 'CNT', 'STA', 'CPA', 'CTY', 'ZIP', 'SAL', 'BNR', 'BNN', 'DIR', 'STR', 'STB', 'STTYP', 'ADL', 'UNID', 'UNIT', 'CAR', 'CEN', 'DESC', 'ADDRK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cs_AddressPartType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cs_AddressPartType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cs_AddressPartType_patterns_, ))
    validate_cs_AddressPartType_patterns_ = [['^[^\\s]*$']]
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descType23', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descType23')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descType23'):
        if self.partType is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            outfile.write(' partType=%s' % (quote_attrib(self.partType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='descType23', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('partType', node)
        if value is not None and 'partType' not in already_processed:
            already_processed.add('partType')
            self.partType = value
            self.validate_cs_AddressPartType(self.partType)    # validate type cs_AddressPartType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


class groupType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qualifier=None):
        self.original_tagname_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType24.subclass:
            return groupType24.subclass(*args_, **kwargs_)
        else:
            return groupType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def add_qualifier(self, value): self.qualifier.append(value)
    def insert_qualifier_at(self, index, value): self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value): self.qualifier[index] = value
    def hasContent_(self):
        if (
            self.qualifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='groupType24', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='groupType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='groupType24'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='groupType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for qualifier_ in self.qualifier:
            qualifier_.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = CR.factory()
            obj_.build(child_)
            self.qualifier.append(obj_)
            obj_.original_tagname_ = 'qualifier'


class htmlType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, head=None, body=None):
        self.original_tagname_ = None
        self.head = head
        self.body = body
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, htmlType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if htmlType4.subclass:
            return htmlType4.subclass(*args_, **kwargs_)
        else:
            return htmlType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_head(self): return self.head
    def set_head(self, head): self.head = head
    def get_body(self): return self.body
    def set_body(self, body): self.body = body
    def hasContent_(self):
        if (
            self.head is not None or
            self.body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='htmlType4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('htmlType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='htmlType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='htmlType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='htmlType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='htmlType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.head is not None:
            self.head.export(outfile, level, namespace_, name_='head', pretty_print=pretty_print)
        if self.body is not None:
            self.body.export(outfile, level, namespace_, name_='body', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'head':
            obj_ = headType.factory()
            obj_.build(child_)
            self.head = obj_
            obj_.original_tagname_ = 'head'
        elif nodeName_ == 'body':
            obj_ = bodyType.factory()
            obj_.build(child_)
            self.body = obj_
            obj_.original_tagname_ = 'body'


